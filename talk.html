<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Talk ‚Äî Community Mural (Firestore, v8)</title>
    <style>
        :root {
            --bg: #030303;
            --panel: #0b0b0b;
            --muted: #9a9a9a;
            --accent: #dfeffb;
            --mono: "Roboto Mono", monospace;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(#050507, #020203);
            color: #fff;
            font-family: var(--mono);
            -webkit-font-smoothing: antialiased;
            overflow: hidden;
        }

        body::after {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.006) 0 1px, transparent 1px 3px);
            mix-blend-mode: screen;
            opacity: 0.06;
            z-index: 1000;
        }

        .scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 999;
            opacity: 0.06;
            background-image: linear-gradient(180deg, rgba(255, 255, 255, 0.01) 0 1px, transparent 1px 3px);
            background-size: 100% 3px;
        }

        @keyframes flicker {
            0% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.03);
            }

            100% {
                filter: brightness(0.98);
            }
        }

        .flicker {
            animation: flicker 2s ease-in-out infinite;
        }

        .intro {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.95);
            flex-direction: column;
            gap: 18px;
        }

        .intro .panel {
            width: min(880px, 92%);
            padding: 28px;
            border-radius: 10px;
            background: linear-gradient(#060606, #0a0a0a);
            border: 1px solid rgba(255, 255, 255, 0.04);
            box-shadow: 0 30px 120px rgba(0, 0, 0, 0.8);
            text-align: center
        }

        .intro h1 {
            font-size: 1.5rem;
            margin: 0;
            letter-spacing: 0.18em;
            color: var(--accent);
            text-transform: uppercase;
        }

        .intro p {
            color: #cfcfcf;
            margin: 10px 0 0;
            font-size: 1rem;
            line-height: 1.3
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: .6rem .9rem;
            border-radius: 6px;
            color: var(--accent);
            cursor: pointer;
            font-weight: 700
        }

        #nameOverlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2100;
            background: rgba(0, 0, 0, 0.85)
        }

        .nameBox {
            width: 320px;
            padding: 18px;
            border-radius: 10px;
            background: linear-gradient(#070707, #0b0b0b);
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .nameBox input {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            background: #050505;
            color: #fff;
            font-family: var(--mono)
        }

        #app {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            z-index: 1;
        }

        header.topbar {
            height: 62px;
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 10px 18px;
            background: linear-gradient(#050505, #0b0b0b);
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            z-index: 50;
        }

        .brand {
            font-size: 1.1rem;
            font-weight: 900;
            letter-spacing: 0.18em;
            color: var(--accent);
            text-transform: uppercase
        }

        .byline {
            opacity: .7;
            font-size: .85rem;
            margin-left: 6px;
            color: var(--muted)
        }

        .stage {
            flex: 1;
            position: relative;
            display: flex;
            gap: 12px;
            padding: 18px;
            align-items: stretch;
            justify-content: stretch;
        }

        .leftPanel {
            width: 320px;
            background: linear-gradient(#060606, #0d0d0d);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            overflow: auto
        }

        .canvasWrap {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            overflow: hidden
        }

        #mural {
            background: #050505;
            width: 100%;
            height: 100%;
            display: block;
        }

        .sectionTitle {
            font-weight: 800;
            color: var(--accent);
            letter-spacing: 0.12em;
            margin-bottom: 8px
        }

        label.small {
            display: block;
            font-size: .78rem;
            color: var(--muted);
            margin-top: 10px
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .tool {
            padding: 8px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.04);
            cursor: pointer;
            color: #fff;
            font-weight: 700
        }

        .tool.active {
            outline: 2px solid rgba(223, 239, 251, 0.06);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6)
        }

        input[type=color] {
            width: 44px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            padding: 0;
            background: #000
        }

        input[type=range] {
            width: 120px
        }

        .stamps {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap
        }

        .stampBtn {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: #070707;
            border: 1px solid rgba(255, 255, 255, 0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px
        }

        .messageForm {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .messageForm input,
        .messageForm textarea {
            background: #050505;
            border: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px;
            border-radius: 6px;
            color: #fff;
            font-family: var(--mono)
        }

        #floating {
            position: absolute;
            inset: 10px;
            pointer-events: none;
            z-index: 30
        }

        .bubble {
            position: absolute;
            pointer-events: auto;
            padding: 8px 10px;
            background: linear-gradient(#080808, #0c0c0c);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            color: #fff;
            max-width: 240px;
            box-shadow: 0 18px 60px rgba(0, 0, 0, 0.6);
            touch-action: none;
            cursor: grab;
            user-select: none;
        }

        .bubble .meta {
            font-size: 11px;
            color: var(--muted);
            margin-top: 8px;
            display: flex;
            justify-content: space-between
        }

        .bubble .adminDelete {
            display: none
        }

        .adminMode .bubble .adminDelete {
            display: inline-block
        }

        #adminGear {
            position: fixed;
            right: 14px;
            top: 14px;
            z-index: 60;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: #070707;
            border: 1px solid rgba(255, 255, 255, 0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer
        }

        #adminGear:hover {
            transform: translateY(-2px)
        }

        .commentBox {
            position: fixed;
            z-index: 2200;
            background: #0b0b0b;
            border: 1px solid rgba(255, 255, 255, 0.04);
            padding: 8px;
            border-radius: 8px;
            min-width: 220px
        }

        .debug {
            position: fixed;
            left: 12px;
            bottom: 12px;
            z-index: 3000;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 6px;
            max-width: 320px;
            font-size: 12px;
            color: #ccc;
            display: none
        }

        @media (max-width:880px) {
            .stage {
                flex-direction: column
            }

            .leftPanel {
                width: 100%;
                order: 2
            }

            .canvasWrap {
                order: 1;
                height: 60vh
            }
        }
    </style>
</head>

<body>
    <div class="scanlines" aria-hidden="true"></div>

    <!-- Intro -->
    <div id="intro" class="intro" role="dialog" aria-label="Welcome overlay">
        <div class="panel flicker">
            <h1 id="introTitle">WELCOME ‚Äî COMMUNITY MURAL</h1>
            <p id="introBody" class="subtle">This is a cozy collaborative wall ‚Äî add drawings, stamps and messages. Be kind.</p>
            <div style="display:flex;gap:10px;align-items:center;margin-top:18px;justify-content:center">
                <button id="agreeBtn" class="btn">Sure thing</button>
            </div>
        </div>
    </div>

    <!-- Name prompt -->
    <div id="nameOverlay" aria-hidden="true">
        <div class="nameBox">
            <div style="font-weight:800;margin-bottom:8px;color:var(--accent)">Choose a display name</div>
            <input id="chooseName" placeholder="Your name (or anon)" maxlength="60">
            <div style="display:flex;gap:8px;margin-top:10px;justify-content:flex-end">
                <button id="nameOk" class="btn">OK</button>
            </div>
        </div>
    </div>

    <!-- App -->
    <div id="app" aria-hidden="true">
        <header class="topbar">
            <div class="brand">S Y N T</div>
            <div class="byline">talk ‚Äî collaborative mural</div>
        </header>

        <div class="stage">
            <aside class="leftPanel">
                <div class="sectionTitle">Tools</div>
                <div class="toolbar" id="toolsRow">
                    <button class="tool active" data-tool="pen">Pen</button>
                    <button class="tool" data-tool="marker">Marker</button>
                    <button class="tool" data-tool="pixel">Pixel</button>
                    <button class="tool" data-tool="spray">Spray</button>
                    <button class="tool" data-tool="eraser">Eraser</button>
                </div>

                <label class="small">Size</label>
                <input id="size" type="range" min="1" max="64" value="6">

                <label class="small">Color</label>
                <input id="color" type="color" value="#ffffff">

                <div style="display:flex;gap:8px;margin-top:10px">
                    <button id="undo" class="tool">Undo</button>
                    <button id="clearLocal" class="tool">Clear</button>
                    <button id="saveBtn" class="tool">Save</button>
                </div>

                <div class="sectionTitle" style="margin-top:14px">Stamps</div>
                <div class="stamps" id="stampsRow"></div>

                <div class="sectionTitle" style="margin-top:12px">Post a message</div>
                <form id="messageForm" class="messageForm" onsubmit="return false;">
                    <input id="name" placeholder="Your name (optional)" maxlength="60">
                    <textarea id="message" rows="3" placeholder="Write a short message (it will float)" maxlength="300"></textarea>
                    <div style="display:flex;gap:8px;align-items:center">
                        <button id="postMsg" class="btn">Post to wall</button>
                        <div class="subtle" style="margin-left:auto" id="msgHint">Messages float & bounce</div>
                    </div>
                </form>

                <div style="height:18px"></div>
                <div class="subtle">Tip: Use stamps, then post a message. Admin can delete.</div>
            </aside>

            <div class="canvasWrap" aria-live="polite">
                <canvas id="mural"></canvas>
                <div id="floating"></div>
            </div>
        </div>
    </div>

    <div id="adminGear" title="Admin">‚öôÔ∏è</div>
    <div id="debug" class="debug" aria-hidden="true"></div>

    <!-- tiny beep placeholder -->
    <audio id="bootSound">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0YQAAAAA=" type="audio/wav">
    </audio>

    <!-- Load Firebase v8 (namespaced) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script>
        // Bind intro button early so it's responsive even if Firebase lags or errors
        document.addEventListener('DOMContentLoaded', function() {
            const agreeBtn = document.getElementById('agreeBtn');
            const intro = document.getElementById('intro');
            const nameOverlay = document.getElementById('nameOverlay');
            const chooseName = document.getElementById('chooseName');
            const nameOk = document.getElementById('nameOk');
            const appEl = document.getElementById('app');
            const bootSound = document.getElementById('bootSound');
            const debug = document.getElementById('debug');

            agreeBtn.addEventListener('click', function() {
                try {
                    bootSound.currentTime = 0;
                    bootSound.play().catch(() => {});
                } catch (e) {}
                intro.style.display = 'none';
                nameOverlay.style.display = 'flex';
                chooseName.focus();
            });

            nameOk.addEventListener('click', function() {
                const v = (chooseName.value || '').trim() || ('anon-' + Math.floor(Math.random() * 9000));
                sessionStorage.setItem('mural_name', v);
                document.getElementById('name').value = v;
                nameOverlay.style.display = 'none';
                appEl.setAttribute('aria-hidden', 'false');
                // after UI visible, initialize Firebase app & mural
                initializeFirebaseAndApp();
            });
        }); // DOMContentLoaded

        // Initialize Firebase using v8 API + then app logic
        function initializeFirebaseAndApp() {
            // show debug if initialization fails
            try {
                // ---------- FIREBASE CONFIG (from user) ----------
                var firebaseConfig = {
                    apiKey: "AIzaSyBeXCRIeRdHr2C3EYnDwC1NoQNQxZygA0U",
                    authDomain: "guestbook-bfbdc.firebaseapp.com",
                    databaseURL: "https://guestbook-bfbdc-default-rtdb.europe-west1.firebasedatabase.app",
                    projectId: "guestbook-bfbdc",
                    storageBucket: "guestbook-bfbdc.firebasestorage.app",
                    messagingSenderId: "710789947600",
                    appId: "1:710789947600:web:19014ef99d053f4c5dbed5",
                    measurementId: "G-E9XPN9563X"
                };
                if (!window.firebase || !firebase.initializeApp) {
                    showDebug('Firebase SDK failed to load. Check network.');
                    return;
                }
                firebase.initializeApp(firebaseConfig);
                var db = firebase.firestore();
                // enable timestampsInSnapshots for older SDKs (no-op in newer)
                try {
                    db.settings({
                        timestampsInSnapshots: true
                    });
                } catch (e) {}

                // call the app initializer with db
                startMuralApp(db);
            } catch (err) {
                showDebug('Firebase init error: ' + (err && err.message));
                console.error(err);
            }

            function showDebug(msg) {
                var d = document.getElementById('debug');
                d.style.display = 'block';
                d.textContent = msg;
                d.setAttribute('aria-hidden', 'false');
            }
        }

        // Main mural app logic (fires after Firebase initialized)
        function startMuralApp(db) {
            // UI refs
            const canvas = document.getElementById('mural');
            const ctx = canvas.getContext('2d');
            const toolsRow = document.getElementById('toolsRow');
            const stampsRow = document.getElementById('stampsRow');
            const colorEl = document.getElementById('color');
            const sizeEl = document.getElementById('size');
            const undoBtn = document.getElementById('undo');
            const clearLocalBtn = document.getElementById('clearLocal');
            const saveBtn = document.getElementById('saveBtn');
            const postMsgBtn = document.getElementById('postMsg');
            const nameInput = document.getElementById('name');
            const msgInput = document.getElementById('message');
            const floating = document.getElementById('floating');
            const adminGear = document.getElementById('adminGear');
            const debug = document.getElementById('debug');

            // state
            let displayName = sessionStorage.getItem('mural_name') || ('anon-' + Math.floor(Math.random() * 9000));
            nameInput.value = displayName;
            let strokes = [];
            let currentStroke = null;
            let imagesOnCanvas = [];
            let drawing = false;
            let currentTool = 'pen';
            const bubbles = {};
            const canvasDocRef = db.collection('mural').doc('canvas');
            const messagesCol = db.collection('mural_messages');
            const ADMIN_PASSWORD = 'indobingo';
            let adminMode = false;

            // fit canvas
            function fitCanvas() {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = Math.max(640, Math.floor(rect.width));
                canvas.height = Math.max(420, Math.floor(rect.height));
                redrawAll();
                // adjust bubbles positions within bounds
                Object.values(bubbles).forEach(b => {
                    b.w = b.el.offsetWidth;
                    b.h = b.el.offsetHeight;
                    b.x = Math.min(Math.max(6, b.x), canvas.width - b.w - 6);
                    b.y = Math.min(Math.max(6, b.y), canvas.height - b.h - 6);
                    b.el.style.left = b.x + 'px';
                    b.el.style.top = b.y + 'px';
                });
            }
            window.addEventListener('resize', debounce(fitCanvas, 120));
            fitCanvas();

            // tools binding
            function setTool(t) {
                currentTool = t;
                Array.from(toolsRow.querySelectorAll('.tool')).forEach(b => b.classList.toggle('active', b.dataset.tool === t));
            }
            toolsRow.addEventListener('click', (e) => {
                const b = e.target.closest('.tool');
                if (!b) return;
                setTool(b.dataset.tool);
            });
            setTool('pen');

            // drawing low-level
            canvas.addEventListener('pointerdown', (e) => {
                if (e.button !== 0) return;
                drawing = true;
                canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
                const p = pointerPos(e);
                currentStroke = {
                    tool: currentTool,
                    color: colorEl.value,
                    size: parseInt(sizeEl.value, 10),
                    points: [p]
                };
                strokes.push(currentStroke);
                drawPoint(p, currentStroke);
            });
            canvas.addEventListener('pointermove', (e) => {
                if (!drawing || !currentStroke) return;
                const p = pointerPos(e);
                currentStroke.points.push(p);
                drawSegment(currentStroke);
            });
            canvas.addEventListener('pointerup', (e) => {
                if (!drawing) return;
                drawing = false;
                currentStroke = null;
                canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
                scheduleSave();
            });

            function pointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function drawPoint(p, stroke) {
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                if (stroke.tool === 'pixel') {
                    const s = stroke.size;
                    ctx.fillStyle = stroke.color;
                    ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);
                } else if (stroke.tool === 'spray') {
                    for (let i = 0; i < 10; i++) {
                        const a = Math.random() * Math.PI * 2;
                        const r = Math.random() * stroke.size * 1.2;
                        ctx.fillStyle = stroke.color;
                        ctx.fillRect(p.x + Math.cos(a) * r, p.y + Math.sin(a) * r, 1.2, 1.2);
                    }
                } else if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, stroke.size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    ctx.strokeStyle = stroke.color;
                    ctx.lineWidth = stroke.size;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + 0.1, p.y + 0.1);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawSegment(stroke) {
                if (!stroke || stroke.points.length < 2) {
                    drawPoint(stroke.points[stroke.points.length - 1], stroke);
                    return;
                }
                const a = stroke.points[stroke.points.length - 2];
                const b = stroke.points[stroke.points.length - 1];
                ctx.save();
                if (stroke.tool === 'pixel') {
                    const s = stroke.size;
                    ctx.fillStyle = stroke.color;
                    ctx.fillRect(b.x - s / 2, b.y - s / 2, s, s);
                } else if (stroke.tool === 'spray') {
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * stroke.size * 1.2;
                        ctx.fillStyle = stroke.color;
                        ctx.fillRect(b.x + Math.cos(angle) * r, b.y + Math.sin(angle) * r, 1.2, 1.2);
                    }
                } else if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.lineWidth = stroke.size * 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    ctx.strokeStyle = stroke.color;
                    ctx.lineWidth = stroke.size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.quadraticCurveTo(a.x, a.y, b.x, b.y);
                    ctx.stroke();
                }
                ctx.restore();
            }

            function redrawAll() {
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                for (const s of strokes) {
                    if (!s || !s.points) continue;
                    if (s.points.length === 1) drawPoint(s.points[0], s);
                    else
                        for (let i = 1; i < s.points.length; i++) {
                            drawSegment({
                                tool: s.tool,
                                color: s.color,
                                size: s.size,
                                points: [s.points[i - 1], s.points[i]]
                            });
                        }
                }
                for (const im of imagesOnCanvas) {
                    ctx.save();
                    ctx.translate(im.x, im.y);
                    ctx.rotate(im.rot || 0);
                    ctx.drawImage(im.img, -im.w / 2, -im.h / 2, im.w, im.h);
                    ctx.restore();
                }
            }

            // undo/clear/save
            undoBtn.addEventListener('click', () => {
                if (strokes.length) {
                    strokes.pop();
                    redrawAll();
                    scheduleSave();
                }
            });
            clearLocalBtn.addEventListener('click', () => {
                if (!confirm('Clear the local drawing layer? This will remove the current canvas for everyone on Save.')) return;
                strokes = [];
                imagesOnCanvas = [];
                redrawAll();
                scheduleSave();
            });
            saveBtn.addEventListener('click', () => saveCanvasToFirestore());

            // stamps
            const STAMPS = [{
                    id: 'cat',
                    label: 'Cat',
                    svg: `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect width='100%' height='100%' fill='#0b0b0b'/><g transform='scale(1.3) translate(6,6)'><rect x='2' y='18' width='40' height='16' fill='#fff'/></g></svg>`
                },
                {
                    id: 'star',
                    label: 'Star',
                    svg: `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect width='100%' height='100%' fill='#050505'/><polygon points='32,6 38,26 60,26 42,38 48,58 32,46 16,58 22,38 4,26 26,26' fill='#ffd36d'/></svg>`
                },
                {
                    id: 'heart',
                    label: 'Heart',
                    svg: `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect width='100%' height='100%' fill='#040404'/><path d='M32 50 L12 30 A8 8 0 0 1 32 14 A8 8 0 0 1 52 30 Z' fill='#ff7aa2'/></svg>`
                }
            ];

            function svgToImg(svg) {
                return new Promise(res => {
                    const b = new Blob([svg], {
                        type: 'image/svg+xml'
                    });
                    const url = URL.createObjectURL(b);
                    const i = new Image();
                    i.onload = () => {
                        URL.revokeObjectURL(url);
                        res(i);
                    };
                    i.onerror = () => res(null);
                    i.src = url;
                });
            }
            (async () => {
                for (const s of STAMPS) {
                    const btn = document.createElement('button');
                    btn.className = 'stampBtn';
                    btn.title = s.label;
                    btn.innerHTML = s.svg;
                    btn.addEventListener('click', async () => {
                        const img = await svgToImg(s.svg);
                        if (!img) return;
                        const w = 120,
                            h = 120;
                        imagesOnCanvas.push({
                            img,
                            x: canvas.width / 2,
                            y: canvas.height / 2,
                            w,
                            h,
                            rot: (Math.random() - 0.5) * 0.4
                        });
                        redrawAll();
                        scheduleSave();
                    });
                    stampsRow.appendChild(btn);
                }
            })();

            // Firestore canvas persistence
            async function saveCanvasToFirestore() {
                try {
                    const imagesData = await Promise.all(imagesOnCanvas.map(async im => {
                        const tmp = document.createElement('canvas');
                        tmp.width = Math.max(64, Math.floor(im.w));
                        tmp.height = Math.max(64, Math.floor(im.h));
                        const tctx = tmp.getContext('2d');
                        tctx.drawImage(im.img, 0, 0, im.w, im.h);
                        return {
                            data: tmp.toDataURL('image/png', 0.9),
                            x: im.x,
                            y: im.y,
                            w: im.w,
                            h: im.h,
                            rot: im.rot
                        };
                    }));
                    const payload = {
                        strokes: strokes,
                        images: imagesData,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    await canvasDocRef.set(payload);
                    saveBtn.textContent = 'Saved ‚úì';
                    setTimeout(() => saveBtn.textContent = 'Save', 1200);
                } catch (e) {
                    alert('Save failed: ' + (e && e.message));
                    console.error(e);
                }
            }
            async function loadCanvasFromFirestoreOnce() {
                try {
                    const snap = await canvasDocRef.get();
                    if (!snap.exists) return;
                    const d = snap.data();
                    strokes = d.strokes || [];
                    imagesOnCanvas.length = 0;
                    if (d.images)
                        for (const im of d.images) {
                            const img = new Image();
                            img.src = im.data;
                            await new Promise(r => img.onload = r);
                            imagesOnCanvas.push({
                                img,
                                x: im.x,
                                y: im.y,
                                w: im.w,
                                h: im.h,
                                rot: im.rot
                            });
                        }
                    redrawAll();
                } catch (e) {
                    console.error('load canvas', e);
                }
            }
            // realtime listener
            canvasDocRef.onSnapshot(function(snap) {
                if (!snap.exists) return;
                const d = snap.data();
                strokes = d.strokes || [];
                imagesOnCanvas.length = 0;
                if (d.images) d.images.forEach(im => {
                    const img = new Image();
                    img.src = im.data;
                    img.onload = () => {
                        imagesOnCanvas.push({
                            img,
                            x: im.x,
                            y: im.y,
                            w: im.w,
                            h: im.h,
                            rot: im.rot
                        });
                        redrawAll();
                    };
                });
                redrawAll();
            });

            // schedule save
            let saveTimer = null;

            function scheduleSave() {
                if (saveTimer) clearTimeout(saveTimer);
                saveTimer = setTimeout(() => saveCanvasToFirestore(), 1200);
            }

            // Messages (bubbles)
            function createBubble(id, data) {
                if (bubbles[id]) return;
                const el = document.createElement('div');
                el.className = 'bubble';
                el.innerHTML = `<div class="text">${escapeHtml(data.text)}</div><div class="meta"><div class="who">${escapeHtml(data.name||'anon')}</div><div class="controls"><button class="tool react">‚ù§ <span class="count">${(data.reactions&&data.reactions.heart)||0}</span></button> <button class="tool comment">üí¨</button> <button class="tool adminDelete">Del</button></div></div>`;
                floating.appendChild(el);
                const startX = (data.x !== undefined) ? data.x : 50 + Math.random() * (canvas.width - 200);
                const startY = (data.y !== undefined) ? data.y : 50 + Math.random() * (canvas.height - 200);
                el.style.left = startX + 'px';
                el.style.top = startY + 'px';
                const rect = el.getBoundingClientRect();
                const state = {
                    id,
                    el,
                    x: startX,
                    y: startY,
                    vx: (Math.random() * 2 - 1) * 0.35,
                    vy: (Math.random() * 2 - 1) * 0.35,
                    w: rect.width,
                    h: rect.height,
                    dragging: false
                };
                bubbles[id] = state;

                el.addEventListener('pointerdown', ev => {
                    state.dragging = true;
                    state.ox = ev.clientX - state.x;
                    state.oy = ev.clientY - state.y;
                    el.setPointerCapture && el.setPointerCapture(ev.pointerId);
                    el.style.cursor = 'grabbing';
                });
                window.addEventListener('pointermove', ev => {
                    if (!state || !state.dragging) return;
                    state.x = ev.clientX - state.ox;
                    state.y = ev.clientY - state.oy;
                    el.style.left = state.x + 'px';
                    el.style.top = state.y + 'px';
                });
                window.addEventListener('pointerup', () => {
                    if (state && state.dragging) {
                        state.dragging = false;
                        el.style.cursor = 'grab';
                        db.collection('mural_messages').doc(id).update({
                            x: state.x,
                            y: state.y
                        }).catch(() => {});
                    }
                });

                const reactBtn = el.querySelector('.react');
                reactBtn.addEventListener('click', () => {
                    const ref = db.collection('mural_messages').doc(id);
                    // simple update increment
                    ref.get().then(snap => {
                        const cur = (snap.exists && snap.data().reactions && snap.data().reactions.heart) || 0;
                        ref.update({
                            'reactions.heart': cur + 1
                        }).catch(() => {});
                    });
                });

                el.querySelector('.comment').addEventListener('click', () => showCommentBoxFor(id, state));

                el.querySelector('.adminDelete').addEventListener('click', () => {
                    if (!adminMode) {
                        alert('Admin only');
                        return;
                    }
                    if (!confirm('Delete message?')) return;
                    db.collection('mural_messages').doc(id).delete().catch(e => alert('Delete failed: ' + e.message));
                });

                // listen for changes to update count
                db.collection('mural_messages').doc(id).onSnapshot(snap => {
                    if (!snap.exists) return;
                    const d = snap.data();
                    const elc = el.querySelector('.count');
                    if (elc) elc.textContent = (d.reactions && d.reactions.heart) || 0;
                });
            }

            // realtime messages listener
            messagesCol.orderBy('createdAt').onSnapshot(function(snap) {
                snap.docChanges().forEach(function(ch) {
                    const id = ch.doc.id;
                    const d = ch.doc.data();
                    if (ch.type === 'added') {
                        createBubble(id, d);
                    } else if (ch.type === 'modified') {
                        const b = bubbles[id];
                        if (b) {
                            b.el.querySelector('.text').textContent = d.text || '';
                            b.el.querySelector('.who').textContent = d.name || 'anon';
                        }
                    } else if (ch.type === 'removed') {
                        const b = bubbles[id];
                        if (b) {
                            b.el.remove();
                            delete bubbles[id];
                        }
                    }
                });
            });

            // post message
            postMsgBtn.addEventListener('click', function() {
                const txt = (msgInput.value || '').trim();
                if (!txt) {
                    alert('Write something first');
                    return;
                }
                const payload = {
                    name: nameInput.value || displayName,
                    text: txt,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    x: Math.random() * (canvas.width - 220) + 30,
                    y: Math.random() * (canvas.height - 140) + 30,
                    reactions: {
                        heart: 0
                    },
                    comments: []
                };
                messagesCol.add(payload).then(() => {
                    msgInput.value = '';
                }).catch(e => alert('Post failed: ' + (e && e.message)));
            });

            // comments UI
            function showCommentBoxFor(id, state) {
                const existing = document.getElementById('commentBox');
                if (existing) existing.remove();
                const box = document.createElement('div');
                box.className = 'commentBox';
                box.id = 'commentBox';
                box.style.left = Math.min(window.innerWidth - 260, Math.max(8, state.x + 30)) + 'px';
                box.style.top = Math.min(window.innerHeight - 220, Math.max(8, state.y + 30)) + 'px';
                box.innerHTML = `<div style="font-weight:700;margin-bottom:6px">Comments</div><div id="commentList" style="max-height:140px;overflow:auto;margin-bottom:6px"></div><input id="commentInput" placeholder="Add a comment" style="width:100%;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#050505;color:#fff;margin-bottom:6px"><div style="display:flex;justify-content:flex-end;gap:8px"><button id="commentSend" class="btn">Send</button><button id="commentClose" class="tool">Close</button></div>`;
                document.body.appendChild(box);
                const list = box.querySelector('#commentList');
                // load comments
                db.collection('mural_messages').doc(id).get().then(snap => {
                    renderComments((snap.data() && snap.data().comments) || []);
                });

                function renderComments(arr) {
                    list.innerHTML = '';
                    (arr || []).forEach(c => {
                        const d = document.createElement('div');
                        d.style.borderBottom = '1px solid rgba(255,255,255,0.02)';
                        d.style.padding = '6px 2px';
                        d.innerHTML = `<div style="font-weight:700">${escapeHtml(c.name||'anon')}</div><div style="font-size:13px">${escapeHtml(c.text)}</div>`;
                        list.appendChild(d);
                    });
                }
                box.querySelector('#commentSend').addEventListener('click', () => {
                    const txt = box.querySelector('#commentInput').value.trim();
                    if (!txt) return;
                    const payload = {
                        name: displayName,
                        text: txt,
                        t: Date.now()
                    };
                    const ref = db.collection('mural_messages').doc(id);
                    ref.get().then(snap => {
                        const cur = (snap.exists && snap.data().comments) || [];
                        cur.push(payload);
                        ref.update({
                            comments: cur
                        });
                        renderComments(cur);
                    }).catch(e => console.error(e));
                    box.querySelector('#commentInput').value = '';
                });
                box.querySelector('#commentClose').addEventListener('click', () => box.remove());
            }

            // simple physics for bubbles
            function physicsTick() {
                const keys = Object.keys(bubbles);
                for (let i = 0; i < keys.length; i++) {
                    const a = bubbles[keys[i]];
                    if (!a) continue;
                    if (!a.dragging) {
                        a.x += a.vx;
                        a.y += a.vy;
                        a.vx *= 0.999;
                        a.vy *= 0.999;
                    }
                    const cw = canvas.width,
                        ch = canvas.height;
                    if (a.x < 6) {
                        a.x = 6;
                        a.vx = Math.abs(a.vx) * 0.6;
                    }
                    if (a.y < 6) {
                        a.y = 6;
                        a.vy = Math.abs(a.vy) * 0.6;
                    }
                    if (a.x + a.w > cw - 6) {
                        a.x = cw - a.w - 6;
                        a.vx = -Math.abs(a.vx) * 0.6;
                    }
                    if (a.y + a.h > ch - 6) {
                        a.y = ch - a.h - 6;
                        a.vy = -Math.abs(a.vy) * 0.6;
                    }
                    for (let j = i + 1; j < keys.length; j++) {
                        const b = bubbles[keys[j]];
                        if (!b) continue;
                        if (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y) {
                            const overlapX = (Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x));
                            const overlapY = (Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y));
                            if (overlapX < overlapY) {
                                const shift = overlapX / 2 + 0.5;
                                if (a.x < b.x) {
                                    a.x -= shift;
                                    b.x += shift;
                                } else {
                                    a.x += shift;
                                    b.x -= shift;
                                }
                                const vxTemp = a.vx;
                                a.vx = b.vx * 0.85;
                                b.vx = vxTemp * 0.85;
                            } else {
                                const shift = overlapY / 2 + 0.5;
                                if (a.y < b.y) {
                                    a.y -= shift;
                                    b.y += shift;
                                } else {
                                    a.y += shift;
                                    b.y -= shift;
                                }
                                const vyTemp = a.vy;
                                a.vy = b.vy * 0.85;
                                b.vy = vyTemp * 0.85;
                            }
                        }
                    }
                    a.el.style.left = a.x + 'px';
                    a.el.style.top = a.y + 'px';
                }
                requestAnimationFrame(physicsTick);
            }
            physicsTick();

            // admin gear
            adminGear.addEventListener('click', () => {
                if (adminMode) {
                    adminMode = false;
                    document.body.classList.remove('adminMode');
                    alert('Admin off');
                    return;
                }
                const p = prompt('Enter admin password:');
                if (p === ADMIN_PASSWORD) {
                    adminMode = true;
                    document.body.classList.add('adminMode');
                    alert('Admin enabled');
                    // add clear button if not present
                    if (!document.getElementById('adminClear')) {
                        const btn = document.createElement('button');
                        btn.className = 'tool';
                        btn.id = 'adminClear';
                        btn.textContent = 'Clear mural';
                        btn.addEventListener('click', async () => {
                            if (!confirm('‚ö†Ô∏è Are you sure you want to CLEAR THE ENTIRE WALL? This cannot be undone.')) return;
                            try {
                                // delete canvas doc
                                await canvasDocRef.delete();
                                // delete messages collection (iterate)
                                const snaps = await messagesCol.get();
                                const batch = db.batch();
                                snaps.forEach(d => batch.delete(messagesCol.doc(d.id)));
                                await batch.commit();
                                // cleanup UI
                                strokes = [];
                                imagesOnCanvas = [];
                                redrawAll();
                                Object.keys(bubbles).forEach(id => {
                                    if (bubbles[id]) bubbles[id].el.remove();
                                    delete bubbles[id];
                                });
                                alert('Cleared');
                            } catch (e) {
                                alert('Clear failed: ' + (e && e.message));
                            }
                        });
                        document.querySelector('.leftPanel .toolbar').appendChild(btn);
                    }
                } else {
                    alert('Wrong password');
                }
            });

            // helpers
            function escapeHtml(s) {
                return (s || '').toString().replace(/[&<>"']/g, c => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                } [c]));
            }

            function debounce(fn, t) {
                let id;
                return (...a) => {
                    clearTimeout(id);
                    id = setTimeout(() => fn(...a), t);
                };
            }

            // basic load once to populate canvas and messages
            loadCanvasFromFirestoreOnce();
            // messages listener already set above via messagesCol.orderBy... onSnapshot
            // but we need to set messagesCol variable to Firestore v8 style
            window.messagesCol = messagesCol; // not used further

            // expose a tiny console if needed
            debug.style.display = 'none';
            console.log('Mural app started');
        } // end startMuralApp
    </script>
</body>

</html>
