<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WELCOME.EXE — Retro Mono UI (Mobile‑first) + Brush Tool</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* ============================
       CORE THEME — MONOCHROME UI
       ============================ */
    :root{
      --bg:#000;      /* UI background */
      --fg:#fff;      /* UI foreground */
      --dim:#b9b9b9;  /* muted text */
      --line:#fff;    /* borders */
      --shadow:#111;  /* hard shadow */

      /* Pattern colours for BG picker (UI stays mono; applied to canvas frame only) */
      --c1:#111; 
      --c2:#eee;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:#000; color:var(--fg);
      font-family:'Press Start 2P', monospace; letter-spacing:.25px; line-height:1.6;
      overflow:hidden;
    }

    /* CRT ambience */
    .crt::before{content:""; position:fixed; inset:0; pointer-events:none; opacity:.5;
      background:repeating-linear-gradient(to bottom, rgba(255,255,255,.04) 0 1px, transparent 1px 3px);
      mix-blend-mode:overlay;
    }
    .crt::after{content:""; position:fixed; inset:0; pointer-events:none;
      background:radial-gradient(120% 85% at 50% 50%, transparent 60%, rgba(0,0,0,.45) 100%);
    }
    @media (max-width:480px){ .crt::before{opacity:.30} }

    /* Desktop bezel vibe (tiny screws) */
    .bezel{position:fixed; inset:18px; pointer-events:none}
    .bezel::before,.bezel::after{content:""; position:absolute; width:6px; height:6px; background:#fff; box-shadow: inset -1px -1px 0 #000, inset 1px 1px 0 #000}
    .bezel::before{left:-14px; top:-14px}
    .bezel::after{right:-14px; bottom:-14px}

    /* ============================
       MAIN WINDOW — RESPONSIVE
       ============================ */
    .window{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      width:min(92vw, 760px); max-height:92vh; background:var(--bg);
      border:4px solid var(--line); box-shadow:10px 10px 0 var(--shadow);
      display:flex; flex-direction:column;
      /* iOS safe area */
      margin:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .titlebar{ display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px; border-bottom:4px solid var(--line); text-transform:uppercase; user-select:none }
    .win-name{font-weight:bold}
    .win-controls{display:flex; gap:8px}
    .ctrl{width:18px; height:18px; border:3px solid var(--line); background:var(--bg)}
    .ctrl:active{transform:translate(1px,1px)}

    .contents{ padding:14px; overflow:auto; -webkit-overflow-scrolling:touch }
    .bio{ font-size:11px; color:var(--dim); text-align:center; margin:0 0 12px }

    /* Layout: on mobile stacked, on desktop two-column with tips */
    .grid{ display:grid; grid-template-columns: 1fr; gap:12px }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1fr 300px } }

    /* Name field */
    .field{ display:flex; align-items:center; gap:10px; justify-content:center; flex-wrap:wrap }
    .field label{font-size:12px}
    .field input{ background:var(--bg); color:var(--fg); border:3px solid var(--line);
      padding:12px 14px; font-size:12px; width:min(360px, 84vw); text-transform:uppercase; outline:none }
    .field input:focus{ box-shadow:0 0 0 3px var(--fg) inset }

    /* Canvas zone */
    .canvas-wrap{ position:relative; width:min(520px, 88vw); margin:6px auto 0 }
    #avatarCanvas{ display:block; width:100%; height:auto; image-rendering:pixelated; border:4px solid var(--line); background:#111; cursor:crosshair; touch-action:none; -webkit-touch-callout:none; user-select:none }
    #gridOverlay{ position:absolute; inset:0; pointer-events:none; display:none; opacity:.35; background:
      repeating-linear-gradient(to right, rgba(255,255,255,.25) 0 1px, transparent 1px 12px),
      repeating-linear-gradient(to bottom, rgba(255,255,255,.25) 0 1px, transparent 1px 12px) }

    /* Toolbar (mono UI) */
    .toolbar{ display:flex; flex-wrap:wrap; justify-content:center; gap:8px; margin:12px 0 }
    .tool{ border:3px solid var(--line); background:var(--bg); color:var(--fg); padding:10px 12px; font-size:11px; cursor:pointer; text-transform:uppercase }
    .tool:hover{ filter:brightness(1.1) }
    .tool:focus-visible{ outline:3px solid #fff; outline-offset:2px }
    .tool:active{ transform:translate(1px,1px) }
    .tool[disabled]{ opacity:.35; filter:grayscale(1); pointer-events:none }
    .toolbar .spacer{ width:16px }

    /* Status bar */
    .status{ display:flex; gap:12px; justify-content:space-between; align-items:center; border-top:4px solid var(--line); padding:8px 10px; font-size:10px; color:var(--dim) }
    .status > div:first-child{ overflow:hidden; white-space:nowrap; text-overflow:ellipsis }

    /* OK button */
    .ok{ display:block; width:240px; margin:12px auto 0; padding:14px; text-align:center; border:4px solid var(--line); background:var(--bg); text-transform:uppercase; cursor:pointer }
    .ok:active{ transform:translate(1px,1px) }
    .ok[disabled]{ opacity:.35; filter:grayscale(1); pointer-events:none }

    /* ============================
       POPOUT WINDOWS
       - desktop: floating draggable
       - mobile: fullscreen overlays
       Only one open at a time via JS
       ============================ */
    .popout{ position:absolute; z-index:50; background:var(--bg); border:4px solid var(--line); box-shadow:8px 8px 0 var(--shadow); width:min(680px, 92vw); display:none }
    .pop-head{ display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:4px solid var(--line); text-transform:uppercase; user-select:none; cursor:move }
    .pop-title{ font-size:12px }
    .pop-close{ position:relative; border:3px solid var(--line); width:26px; height:26px; background:var(--bg); cursor:pointer }
    .pop-close::before{ content:'✕'; position:absolute; inset:0; display:grid; place-items:center; font-size:14px; color:#fff }
    .pop-body{ padding:12px; max-height:70vh; overflow:auto; -webkit-overflow-scrolling:touch }

    /* Mobile treatment for popouts: turn into fullscreen pane */
    @media (max-width: 700px){
      .popout{ position:fixed; inset:0; width:100vw; height:100vh; transform:none !important; box-shadow:none; border-width:6px }
      .pop-head{ cursor:default }
      .pop-body{ max-height: calc(100vh - 60px); }
      .tool{ padding:12px 14px; font-size:12px }
      .field input{ font-size:12px; padding:12px 14px }
    }

    /* Brush chooser UI (mono) */
    .brush-list{ display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:8px; margin-bottom:12px }
    .chip{ border:3px solid var(--line); padding:12px 8px; text-align:center; font-size:11px; cursor:pointer; user-select:none }
    .chip.active, .chip:hover{ background:var(--fg); color:var(--bg) }

    .row{ display:flex; align-items:center; gap:12px; margin:10px 0; font-size:11px; flex-wrap:wrap }
    .swatch{ width:26px; height:26px; border:3px solid var(--line); background:#fff }

    /* Retro slider styling */
    input[type=range]{ -webkit-appearance:none; width:100%; background:transparent }
    input[type=range]::-webkit-slider-runnable-track{ height:14px; background: repeating-linear-gradient(90deg, var(--fg) 0 2px, transparent 2px 6px); border:3px solid var(--line) }
    input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:20px; height:20px; background:var(--fg); border:3px solid var(--line); margin-top:-5px }
    input[type=range]::-moz-range-track{ height:14px; background: repeating-linear-gradient(90deg, var(--fg) 0 2px, transparent 2px 6px); border:3px solid var(--line) }
    input[type=range]::-moz-range-thumb{ width:20px; height:20px; background:var(--fg); border:3px solid var(--line) }

    /* Tips card */
    .tip{ border:3px solid var(--line); padding:10px; font-size:11px; color:var(--dim) }
  </style>
</head>
<body class="crt">

  <div class="bezel"></div>

  <div class="window" id="win">
    <div class="titlebar" id="dragWin">
      <div class="win-name">WELCOME.EXE</div>
      <div class="win-controls">
        <span class="ctrl" title="min"></span>
        <span class="ctrl" title="max"></span>
        <span class="ctrl" title="close"></span>
      </div>
    </div>

    <div class="contents">
      <div class="bio">Monochrome interface • Colour canvas. Choose a name, sketch an avatar, and step in.</div>

      <div class="grid">
        <div>
          <div class="field">
            <label for="username">NAME</label>
            <input id="username" type="text" placeholder="ENTER NAME" />
          </div>

          <div class="canvas-wrap">
            <!-- NOTE: Canvas uses full colour; UI remains mono -->
            <canvas id="avatarCanvas" width="256" height="256"></canvas>
            <div id="gridOverlay"></div>
          </div>

          <div class="toolbar">
            <button class="tool" id="brushBtn">BRUSH</button>
            <button class="tool" id="eraserBtn" disabled>ERASE</button>
            <button class="tool" id="bucketBtn" disabled>FILL</button>
            <button class="tool" id="stampBtn" disabled>STAMP</button>
            <button class="tool" id="bgBtn" disabled>BG</button>
            <span class="spacer"></span>
            <button class="tool" id="gridBtn">GRID</button>
            <button class="tool" id="undoBtn">UNDO</button>
            <button class="tool" id="redoBtn">REDO</button>
          </div>
        </div>

        <div class="tip">
          <div><strong>TIP</strong></div>
          <div style="margin-top:6px">Tap <b>BRUSH</b> to open the tool panel. On phones, panels use fullscreen; on desktop, they float. Only one panel opens at a time.</div>
          <div style="margin-top:6px">Press <b>G</b> to toggle the pixel grid. The UI is strictly black/white, but the canvas accepts any colours.</div>
        </div>
      </div>

      <button class="ok" id="okBtn" disabled>OK!</button>
    </div>

    <div class="status">
      <div id="statusText">STATUS: Waiting for name…</div>
      <div>v0.3.1 • MOBILE‑FIRST</div>
    </div>
  </div>

  <!-- ============================
       BRUSH POPOUT (fully working)
       ============================ -->
  <div class="popout" id="brushPop" style="left:50%; top:10%; transform:translateX(-50%)">
    <div class="pop-head" id="dragBrush">
      <div class="pop-title">BRUSH</div>
      <button class="pop-close" data-close="#brushPop" aria-label="Close"></button>
    </div>
    <div class="pop-body">
      <div class="brush-list" id="brushList">
        <div class="chip active" data-brush="pencil">PENCIL</div>
        <div class="chip" data-brush="paint">PAINT</div>
        <div class="chip" data-brush="spray">SPRAY</div>
        <div class="chip" data-brush="marker">MARKER</div>
      </div>
      <div class="row">
        <span>SIZE</span>
        <input id="brushSize" type="range" min="1" max="32" value="6" />
        <span id="brushSizeVal">6</span>
      </div>
      <div class="row">
        <span>COLOUR</span>
        <div class="swatch" id="colourSwatch" title="Tap to pick colour"></div>
        <input id="colourPicker" type="color" value="#ffffff" style="appearance:none; border:0; background:transparent; width:1px; height:1px; opacity:0; position:absolute" />
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="tool" id="brushOK">OK</button>
      </div>
    </div>
  </div>

  <script>
    /* ============================
       JS: Helpers
       ============================ */
    function makeDraggable(el, handle){
      let offX=0, offY=0, dragging=false;
      function down(e){ dragging=true; const p=e.touches?e.touches[0]:e; const r=el.getBoundingClientRect(); offX=p.clientX-r.left; offY=p.clientY-r.top; document.body.style.userSelect='none'; }
      function move(e){ if(!dragging) return; const p=e.touches?e.touches[0]:e; const x=p.clientX-offX; const y=p.clientY-offY; el.style.left=x+'px'; el.style.top=y+'px'; el.style.transform='none'; }
      function up(){ dragging=false; document.body.style.userSelect=''; }
      handle.addEventListener('mousedown', down); window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
      handle.addEventListener('touchstart', down, {passive:true}); window.addEventListener('touchmove', move, {passive:true}); window.addEventListener('touchend', up);
    }

    // Open one popout at a time
    function openPop(id){ document.querySelectorAll('.popout').forEach(p=>p.style.display='none'); const el = document.getElementById(id); el.style.display='block'; }
    function closePop(id){ const el = document.querySelector(id); if(el) el.style.display='none'; }

    // Grid toggle
    const gridOverlay = document.getElementById('gridOverlay');
    const gridBtn = document.getElementById('gridBtn');
    function toggleGrid(){ gridOverlay.style.display = (gridOverlay.style.display==='block') ? 'none' : 'block'; }
    gridBtn.addEventListener('click', toggleGrid);
    window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='g') toggleGrid(); });

    // Draggable (desktop only — on mobile, popouts go fullscreen so dragging is unnecessary)
    const win = document.getElementById('win');
    makeDraggable(win, document.getElementById('dragWin'));
    makeDraggable(document.getElementById('brushPop'), document.getElementById('dragBrush'));

    // Close buttons
    document.querySelectorAll('.pop-close').forEach(btn=>{
      btn.addEventListener('click', ()=> closePop(btn.dataset.close));
    });

    /* ============================
       Canvas + Drawing Engine (Brush only)
       ============================ */
    const canvas = document.getElementById('avatarCanvas');
    const ctx = canvas.getContext('2d');
    // Start with a dark background (users can change later via BG tool in future)
    ctx.fillStyle = '#111'; ctx.fillRect(0,0,canvas.width,canvas.height);
    let drawing=false, last=null;

    // Brush state
    let brushType='pencil';
    let brushSize=6; // px
    let brushColour='#ffffff';

    const brushBtn = document.getElementById('brushBtn');
    brushBtn.addEventListener('click', ()=> openPop('brushPop'));

    // Brush UI interactions
    const brushList = document.getElementById('brushList');
    brushList.addEventListener('click', (e)=>{
      const chip = e.target.closest('.chip'); if(!chip) return;
      document.querySelectorAll('#brushList .chip').forEach(c=>c.classList.remove('active'));
      chip.classList.add('active');
      brushType = chip.dataset.brush;
    });
    const size = document.getElementById('brushSize');
    const sizeVal = document.getElementById('brushSizeVal');
    size.addEventListener('input', ()=>{ brushSize = parseInt(size.value,10); sizeVal.textContent = brushSize; });

    const colourPicker = document.getElementById('colourPicker');
    const colourSwatch = document.getElementById('colourSwatch');
    function setSwatch(col){ colourSwatch.style.background = col; }
    setSwatch(brushColour);
    colourSwatch.addEventListener('click', ()=> colourPicker.click());
    colourPicker.addEventListener('input', (e)=>{ brushColour = e.target.value; setSwatch(brushColour); });

    document.getElementById('brushOK').addEventListener('click', ()=> closePop('#brushPop'));

    // Undo/Redo stacks
    const undoStack=[]; const redoStack=[]; const MAX_STACK=20;
    function pushUndo(){ try{ const snap = ctx.getImageData(0,0,canvas.width,canvas.height); undoStack.push(snap); if(undoStack.length>MAX_STACK) undoStack.shift(); redoStack.length=0; }catch(e){} }
    function doUndo(){ if(!undoStack.length) return; const snap = undoStack.pop(); const current = ctx.getImageData(0,0,canvas.width,canvas.height); redoStack.push(current); ctx.putImageData(snap,0,0); }
    function doRedo(){ if(!redoStack.length) return; const snap = redoStack.pop(); const current = ctx.getImageData(0,0,canvas.width,canvas.height); undoStack.push(current); ctx.putImageData(snap,0,0); }
    document.getElementById('undoBtn').addEventListener('click', doUndo);
    document.getElementById('redoBtn').addEventListener('click', doRedo);

    // Drawing helpers
    function drawDot(x,y,size,colour,alpha=1){
      ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = colour; ctx.beginPath(); ctx.arc(x,y,size/2,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
    function lineTo(x0,y0,x1,y1,stepCb){
      const dx=x1-x0, dy=y1-y0; const steps=Math.max(Math.abs(dx), Math.abs(dy));
      for(let i=0;i<=steps;i++){
        const t=steps? i/steps : 0; const x=x0+dx*t; const y=y0+dy*t; stepCb(x,y);
      }
    }

    function onPointerDown(e){
      const rect = canvas.getBoundingClientRect();
      const clientX = e.clientX ?? (e.touches&&e.touches[0].clientX);
      const clientY = e.clientY ?? (e.touches&&e.touches[0].clientY);
      const x = Math.floor((clientX - rect.left) * (canvas.width/rect.width));
      const y = Math.floor((clientY - rect.top) * (canvas.height/rect.height));
      pushUndo(); drawing=true; last={x,y};
      applyBrush(x,y, true);
    }
    function onPointerMove(e){ if(!drawing) return; const rect = canvas.getBoundingClientRect(); const clientX = e.clientX ?? (e.touches&&e.touches[0].clientX); const clientY = e.clientY ?? (e.touches&&e.touches[0].clientY);
      const x = Math.floor((clientX - rect.left) * (canvas.width/rect.width));
      const y = Math.floor((clientY - rect.top) * (canvas.height/rect.height));
      if(last){ lineTo(last.x,last.y,x,y,(lx,ly)=> applyBrush(lx,ly,false)); } last={x,y};
    }
    function onPointerUp(){ drawing=false; last=null; }

    function applyBrush(x,y,isFirst){
      // Different behaviours per brush
      switch(brushType){
        case 'pencil':
          drawDot(x,y,Math.max(1,brushSize), brushColour, 1);
          break;
        case 'paint': // thicker, slight jitter texture
          const n = 6; for(let i=0;i<n;i++){ const jx = x + (Math.random()-0.5)*brushSize*0.6; const jy = y + (Math.random()-0.5)*brushSize*0.6; drawDot(jx,jy,brushSize*0.9, brushColour, 0.95); }
          break;
        case 'spray':
          const density = 20 + brushSize*2;
          for(let i=0;i<density;i++){ const r = Math.random()*brushSize; const a = Math.random()*Math.PI*2; const sx = x + Math.cos(a)*r; const sy = y + Math.sin(a)*r; drawDot(sx,sy,1+Math.random()*2, brushColour, 0.35); }
          break;
        case 'marker': // semi-transparent layering
          drawDot(x,y,brushSize*1.2, brushColour, 0.35);
          break;
      }
    }

    // Mouse + touch support
    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', (e)=>{ onPointerDown(e); }, {passive:true});
    window.addEventListener('touchmove', (e)=>{ onPointerMove(e); }, {passive:true});
    window.addEventListener('touchend', onPointerUp);

    /* ============================
       Status + OK enable rules
       ============================ */
    const nameInput = document.getElementById('username');
    const statusText = document.getElementById('statusText');
    const okBtn = document.getElementById('okBtn');
    nameInput.addEventListener('input', ()=>{
      const hasName = !!nameInput.value.trim();
      statusText.textContent = hasName ? `Hello, ${nameInput.value.trim()}. Sketch your avatar →` : 'STATUS: Waiting for name…';
      okBtn.disabled = !hasName;
    });

    /* ============================
       One‑at‑a‑time popout logic
       ============================ */
    document.getElementById('brushBtn').addEventListener('click', ()=> openPop('brushPop'));
    document.querySelectorAll('.pop-close').forEach(btn=> btn.addEventListener('click', ()=> closePop(btn.dataset.close)));

    // Accessibility: reduce CRT if user prefers reduced motion
    const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
    if(mq.matches){ document.body.classList.remove('crt'); }
  </script>
</body>
</html>
