<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>synt — everything feels different in the dark</title>
<meta name="description" content="synt — ambient sounds and visuals. Everything feels different in the dark.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="synt — everything feels different in the dark">
<meta property="og:description" content="synt — ambient sounds and visuals. Everything feels different in the dark.">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<style>
:root{
  --bg: #0a0a0a;
  --fg: #ffffff;
  --card-bg: #111;
  --input-bg: #000;
  --input-border: #444;
  --accent: rgba(255,255,255,0.06);
  --success: #0f0;
  --error: #ff5c5c;

  --border-width: 2px;
  --border-color: var(--fg);

  --page-padding: clamp(1rem, 3vw, 2.25rem);
  --max-content-width: 1200px;
  --stage-offset: 3.2vh;
  --stage-gap: 1.05rem;
  --logo-byline-gap: 0.18rem;
  --byline-menu-gap: 0.7rem;

  --menu-gap: 0.72rem;
  --menu-padding-vertical: 0.85rem;
  --menu-padding-horizontal: 1.6rem;
  --menu-min-width: 120px;

  --control-padding: 0.5rem;

  --font-family: monospace, ui-monospace, "SFMono-Regular", Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
  --byline-size: 0.95rem;

  --shadow-small: 0 0 6px #fff;
  --shadow-medium: 0 0 18px #fff;
  --shadow-large: 0 0 40px rgba(255,255,255,0.6);

  --flicker-brightness: 1;
}

/* Base */
html,body {
  height: 100%;
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: var(--font-family);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
}

/* Accessibility helper */
.visually-hidden {
  position: absolute !important;
  width: 1px; height: 1px;
  overflow: hidden;
  clip: rect(1px,1px,1px,1px);
  white-space: nowrap;
}

/* Skip link */
.skip-link {
  position: absolute;
  left: -9999px;
  width: 1px; height: 1px; overflow: hidden;
}
.skip-link:focus {
  left: 1rem; top: 1rem;
  width: auto; height: auto;
  padding: .5rem 1rem;
  background: #222; color: var(--fg);
  z-index: 9999; text-decoration: none; border-radius: 6px;
}

/* Strong film grain for grittier look */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background:
    repeating-linear-gradient(to bottom, rgba(255,255,255,0.03) 0 1px, transparent 1px 3px),
    radial-gradient(circle at 30% 20%, rgba(255,255,255,0.01), transparent 10%),
    radial-gradient(circle at 70% 80%, rgba(255,255,255,0.01), transparent 8%);
  pointer-events: none;
  z-index: 5;
  mix-blend-mode: overlay;
  opacity: 0.95;
}

/* Main centering */
main#main {
  min-height: 100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: var(--page-padding);
  position: relative;
}

/* ---------- INTRO OVERLAY (monochrome & gritty) ---------- */
.intro-overlay {
  position: fixed;
  inset: 0;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  flex-direction: column;
  color: #fff; /* strictly white text */
  font-family: var(--font-family);
  text-align: center;
  gap: 0.8rem;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* noise and pixel textures */
.intro-noise {
  position: absolute; inset: 0;
  background-image:
    radial-gradient(circle at 10% 20%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    radial-gradient(circle at 80% 30%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    radial-gradient(circle at 40% 70%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.015) 0 1px, transparent 1px 2px);
  background-size: 6px 6px, 6px 6px, 6px 6px, 4px 4px;
  opacity: 0.12;
  pointer-events: none;
  mix-blend-mode: screen;
}

/* scan sweep faster */
.scanline {
  position: absolute;
  left: -10%;
  width: 120%;
  height: 28vh;
  top: -40%;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  transform: skewY(-10deg);
  opacity: 0.06;
  filter: blur(6px) contrast(120%);
  animation: sweep 1.6s linear 0s 1;
  pointer-events: none;
  mix-blend-mode: screen;
}
@keyframes sweep { to { transform: translateY(240%) skewY(-10deg); opacity: 0; } }

.scan-vert {
  position: absolute; inset: 0;
  background-image: linear-gradient(90deg, rgba(255,255,255,0.012) 0 1px, transparent 1px 3px);
  opacity: 0.045;
  pointer-events: none;
  mix-blend-mode: screen;
}

.pixel-grid {
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(transparent 0 95%, rgba(255,255,255,0.01) 95% 100%),
    linear-gradient(90deg, transparent 0 95%, rgba(255,255,255,0.01) 95% 100%);
  background-size: 6px 6px, 6px 6px;
  opacity: 0.08;
  pointer-events: none;
  mix-blend-mode: screen;
}

/* flash overlay */
.intro-flash {
  position: absolute; inset: 0;
  background: white;
  opacity: 0;
  pointer-events: none;
}

/* Boot text - monochrome, bold */
.boot {
  z-index: 1000;
  max-width: 80ch;
  font-size: clamp(0.95rem, 1.9vw, 1.1rem);
  line-height: 1.18;
  text-align: left;
  color: #fff;
  letter-spacing: 0.02em;
  filter: drop-shadow(0 0 6px rgba(255,255,255,0.06));
  transform: translateZ(0);
  font-weight: 700;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: none;
}
.boot-line { display:block; white-space: pre; font-variant-numeric: tabular-nums; }

/* glitch logo (monochrome duplicates for roughness) */
.glitch {
  position: relative;
  display: inline-block;
  color: #fff;
  font-weight: 900;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  font-size: 0.9rem;
  filter: drop-shadow(0 0 6px rgba(255,255,255,0.06));
}
.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute; left: 0; top: 0; width: 100%;
  pointer-events: none;
  color: #fff;
  opacity: 0.9;
  mix-blend-mode: normal;
}
.glitch::before { transform: translateX(-1px) translateY(-1px) scale(1.003); opacity: 0.6; }
.glitch::after  { transform: translateX(1px) translateY(1px) scale(0.997); opacity: 0.5; }

/* small sound enable button (only shown if audio blocked) */
.sound-enable {
  position: absolute;
  top: 12px;
  right: 12px;
  z-index: 1010;
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.12);
  padding: .35rem .6rem;
  font-family: var(--font-family);
  cursor: pointer;
  border-radius: 6px;
  font-size: .85rem;
  backdrop-filter: blur(4px);
  display: none;
}
.sound-enable:active { transform: translateY(1px); }

/* ---------- STAGE (site) ---------- */
.stage {
  width: min(var(--max-content-width), 100%);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: var(--stage-gap);
  position: relative; z-index: 10;
  opacity: 1;
  transition: opacity .35s ease, transform .35s ease;
  transform: translateY(var(--stage-offset));
}

.logo {
  font-size: clamp(4rem, 18vw, 14rem);
  font-weight: bold;
  text-transform: uppercase;
  color: var(--fg);
  filter: brightness(var(--flicker-brightness));
  text-shadow: var(--shadow-small), var(--shadow-medium), var(--shadow-large);
  transition: filter .1s ease, text-shadow .1s ease;
  letter-spacing: -0.05em;
  font-kerning: normal;
  text-rendering: optimizeLegibility;
  margin: 0;
}

.byline {
  font-size: var(--byline-size);
  opacity: 0.65;
  margin: 0;
  padding-top: var(--logo-byline-gap);
  letter-spacing: 0.18em;
}

.menu {
  display:flex;
  gap: var(--menu-gap);
  margin-top: var(--byline-menu-gap);
  justify-content:center;
  flex-wrap:wrap;
  opacity: 0;
  transition: opacity .6s ease;
}

.menu-box {
  background: transparent;
  color: var(--fg);
  border: var(--border-width) solid var(--border-color);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  padding: var(--menu-padding-vertical) var(--menu-padding-horizontal);
  font-family: inherit;
  font-size: inherit;
  text-align: center;
  -webkit-appearance: none;
  -moz-appearance: none;
  border-radius: 6px;
  min-width: var(--menu-min-width);
}
.menu-box::after {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--accent);
  transform: translateY(100%);
  transition: transform .22s ease;
  pointer-events: none;
}
.menu-box:hover::after { transform: translateY(0); }
.menu-box:hover { filter: brightness(1.4); }

/* Popup + sections */
.popup {
  position: fixed; inset: 0; background: rgba(0,0,0,0.9);
  display: none; flex-direction: column; align-items: center; justify-content:center; z-index:100;
}
.popup form {
  display:flex; flex-direction:column; gap:1rem; background:var(--card-bg); padding:2rem; border:var(--border-width) solid var(--border-color); width:320px; border-radius:8px;
}
.popup input, .popup textarea { background:var(--input-bg); color:var(--fg); border:1px solid var(--input-border); padding:var(--control-padding); font-family:var(--font-family); border-radius:6px; }
.popup button[type="submit"] { background:var(--fg); color:var(--bg); border:none; padding:.6rem; cursor:pointer; font-weight:bold; border-radius:6px; }
.form-status { font-size:.9rem; color:var(--success); }

.section { position:fixed; inset:0; background:var(--bg); display:none; flex-direction:column; align-items:center; padding:2rem; overflow-y:auto; z-index:90; }
.section h1 { text-transform:uppercase; margin-bottom:2rem; }
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:1rem; width:100%; max-width:var(--max-content-width); }
.track, .visual { background:var(--card-bg); padding:1rem; border:var(--border-width) solid var(--border-color); border-radius:6px; }
.track audio { width:100% } .visual img { width:100%; height:auto; display:block; }

.back-btn { margin-top:2rem; cursor:pointer; text-transform:uppercase; letter-spacing:.1em; border:var(--border-width) solid var(--border-color); padding:.5rem 1rem; background:transparent; color:var(--fg); border-radius:6px; }
.back-btn:hover { filter:brightness(1.4); }

/* Responsive */
@media (max-width:880px){ :root{--stage-offset:3vh;--stage-gap:0.9rem} .menu-box{min-width:100px;padding-inline:1.25rem} }
@media (max-width:520px){ :root{--stage-offset:2vh} .logo{font-size:clamp(2.2rem,14vw,6.6rem);letter-spacing:-0.03em} .menu{gap:0.45rem;margin-top:0.45rem} .menu-box{min-width:84px;padding:.7rem 1rem;font-size:.95rem} .popup form{width:92%;max-width:420px;padding:1rem} }

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .stage, .menu-box, .menu-box::after, body::before, .scanline, .intro-overlay { transition: none !important; animation: none !important; }
}

/* Guestbook base variables (we override with retro look later) */
:root {
  --gb-bg: var(--card-bg);
  --gb-text: var(--fg);
  --gb-accent: var(--accent);
  --gb-muted: rgba(255,255,255,0.36);
  --gb-radius: 8px;
  --gb-shadow: 0 18px 60px rgba(0,0,0,0.7);
  --gb-font: var(--font-family);
  --gb-line: rgba(255,255,255,0.04);
}

/* ---------- keep the rest of your original site CSS intact ---------- */
/* (Everything above remains the same as your original file) */

/* Subtle TV grain enhancement */
body::before {
  background:
    repeating-linear-gradient(to bottom, rgba(255,255,255,0.025) 0 1px, transparent 1px 3px),
    radial-gradient(circle at 30% 20%, rgba(255,255,255,0.01), transparent 10%),
    radial-gradient(circle at 70% 80%, rgba(255,255,255,0.01), transparent 8%);
  opacity: 0.75;
}

/* Flicker effect */
@keyframes subtleFlicker {
  0%, 100% { filter: brightness(1); }
  45% { filter: brightness(1.05); }
  50% { filter: brightness(0.98); }
  55% { filter: brightness(1.04); }
}
.intro-overlay {
  animation: subtleFlicker 1.8s infinite;
}

</style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to content</a>

  <!-- Intro overlay -->
  <div id="intro" class="intro-overlay" aria-hidden="true" role="dialog" aria-label="Startup">
    <div class="intro-noise" aria-hidden="true"></div>
    <div class="scanline" aria-hidden="true"></div>
    <div class="scan-vert" aria-hidden="true"></div>
    <div class="pixel-grid" aria-hidden="true"></div>
    <div class="intro-flash" id="introFlash" aria-hidden="true"></div>

    <!-- optional small button to enable sound if browser blocks autoplay -->
    <button id="soundEnableBtn" class="sound-enable" aria-hidden="true">Enable sound</button>

    <div class="boot" id="bootText" aria-hidden="false" role="status" aria-live="polite">
      <span class="boot-line" id="line1"></span>
      <span class="boot-line" id="line2"></span>
      <span class="boot-line" id="line3"></span>
      <span class="boot-line" id="line4"></span>
    </div>

    <div style="font-size:.85rem;opacity:.95;color:#fff;margin-top:6vh">
      <span class="glitch" id="bootLogo" data-text="S Y N T">S Y N T</span>
    </div>
  </div>

  <main id="main" aria-hidden="false">
    <header class="stage" id="stage" role="banner" aria-hidden="false">
      <h1 id="logo" class="logo" tabindex="-1">synt</h1>
      <p class="byline">everything feels different in the dark</p>

      <nav class="menu" id="menu" aria-label="Primary">
        <button class="menu-box" data-section="sounds" type="button">Sounds</button>
        <button class="menu-box" data-section="visuals" type="button">Visuals</button>
        <button class="menu-box" id="gbTrigger" type="button">Talk</button>
        <!-- Embedded synth button (preserved) -->
      </nav>
    </header>

    <!-- Sounds Section -->
    <section class="section" id="sounds" role="region" aria-labelledby="sounds-heading" aria-hidden="true">
      <h1 id="sounds-heading" tabindex="-1">Sounds</h1>
      <div class="grid">
        <div class="track">
          <strong>Track 1</strong>
          <audio controls preload="none">
            <source src="your-audio.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
          </audio>
        </div>
        <div class="track">
          <strong>Track 2</strong>
          <audio controls preload="none">
            <source src="your-audio2.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
          </audio>
        </div>
      </div>
      <button class="back-btn" type="button" onclick="goHome()">Back</button>
    </section>

    <!-- Visuals Section -->
    <section class="section" id="visuals" role="region" aria-labelledby="visuals-heading" aria-hidden="true">
      <h1 id="visuals-heading" tabindex="-1">Visuals</h1>
      <div class="grid">
        <div class="visual">
          <img src="everything feels different in the dark.png" alt="Album artwork: everything feels different in the dark" width="800" height="600" loading="lazy">
        </div>
        <div class="visual">
          <img src="https://placehold.co/400x300" alt="Placeholder visual" loading="lazy" width="400" height="300">
        </div>
      </div>
      <button class="back-btn" type="button" onclick="goHome()">Back</button>
    </section>
  </main>

  <!-- Intro audio -->
  <audio id="introAudio" preload="auto">
    <source src="boot.wav" type="audio/wav">
    <source src="boot.mp3" type="audio/mpeg">
  </audio>

  <!-- Ambient background audio -->
  <audio id="ambientAudio" loop preload="none">
    <source src="ambient.mp3" type="audio/mpeg">
  </audio>

  <!-- Hidden flicker sound effects -->
  <audio id="flickerSound1" preload="none"><source src="flicker1.mp3" type="audio/mpeg"></audio>
  <audio id="flickerSound2" preload="none"><source src="flicker2.mp3" type="audio/mpeg"></audio>

<!-- === ORIGINAL SITE JS (kept and optimized for performance) === -->
<script>
/* Original intro / UI JS restored and slightly optimized — unchanged visuals */
(() => {
  'use strict';

  /* ===============
     Cached elements & state (same as original, preserved)
  =============== */
  const mainEl = document.querySelector('main');
  const introOverlay = document.getElementById('intro');
  const bootLinesEls = [
    document.getElementById('line1'),
    document.getElementById('line2'),
    document.getElementById('line3'),
    document.getElementById('line4')
  ];
  const bootLogo = document.getElementById('bootLogo');
  const introFlash = document.getElementById('introFlash');
  const soundEnableBtn = document.getElementById('soundEnableBtn');

  const introAudio = document.getElementById('introAudio');
  const ambientAudio = document.getElementById('ambientAudio');

  const logo = document.getElementById('logo');
  const menu = document.getElementById('menu');
  const stage = document.getElementById('stage');
  const sections = Array.from(document.querySelectorAll('.section'));
  const tellBtn = document.getElementById('tellBtn');

  let lastFocusedElement = null;
  let modalKeyHandler = null;
  let flickerLoopTimer = null;
  let ambientFadeInterval = null;
  let introAudioAllowed = false;
  let activeTimeouts = new Set();
  let activeIntervals = new Set();

  const safe = {
    setItem(key, value) {
      try { localStorage.setItem(key, value); } catch (e) { /* ignore */ }
    },
    getItem(key) {
      try { return localStorage.getItem(key); } catch (e) { return null; }
    }
  };

  function prefersReducedMotion() {
    return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  function setIntroPlayedFlag() {
    safe.setItem('synt_intro_played', '1');
  }
  function introWasPlayed() {
    return safe.getItem('synt_intro_played') === '1';
  }

  function wait(ms) {
    return new Promise(resolve => {
      const t = setTimeout(() => {
        activeTimeouts.delete(t);
        resolve();
      }, ms);
      activeTimeouts.add(t);
    });
  }

  function setTimeoutTracked(fn, ms) {
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.add(id);
    return id;
  }
  function clearAllTrackedTimeouts() {
    activeTimeouts.forEach(id => clearTimeout(id));
    activeTimeouts.clear();
  }

  function setIntervalTracked(fn, ms) {
    const id = setInterval(fn, ms);
    activeIntervals.add(id);
    return id;
  }
  function clearAllTrackedIntervals() {
    activeIntervals.forEach(id => clearInterval(id));
    activeIntervals.clear();
  }

  function typeText(el, text, charDelay = 18) {
    return new Promise(resolve => {
      el.textContent = '';
      let i = 0;
      function step() {
        if (i >= text.length) return resolve();
        el.textContent += text[i++];
        setTimeout(step, charDelay + Math.random() * 14);
      }
      step();
    });
  }

  function grittyGlitch(el, repeats = 6, intensity = 1.6, speed = 60) {
    return new Promise(resolve => {
      let count = 0;
      const id = setInterval(() => {
        el.style.transform = `translate(${(Math.random() - 0.5) * intensity}px, ${(Math.random() - 0.5) * intensity}px) skew(${(Math.random() - 0.5) * 0.8}deg)`;
        el.style.opacity = 0.85 + Math.random() * 0.18;
        count++;
        if (count >= repeats) {
          clearInterval(id);
          el.style.transform = '';
          el.style.opacity = '';
          activeIntervals.delete(id);
          resolve();
        }
      }, speed);
      activeIntervals.add(id);
    });
  }

  function flashIntro(duration = 90) {
    if (introFlash) {
      introFlash.style.transition = `opacity ${duration}ms ease-out`;
      introFlash.style.opacity = '0.95';
      setTimeout(() => { introFlash.style.opacity = '0'; }, 30);
    }
  }

  function hideIntroOverlay() {
    introOverlay.style.transition = 'opacity 300ms ease';
    introOverlay.style.opacity = 0;
    clearAllTrackedIntervals();
    setTimeout(() => {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
    }, 360);
  }

  function showMainUI() {
    mainEl.setAttribute('aria-hidden', 'false');
    stage.style.opacity = 1;
    setTimeout(() => { menu.style.opacity = 1; }, 420);
    startFlickerLoop();
  }

  async function tryPlayIntroAudio() {
    if (!introAudio) return false;
    try {
      introAudio.volume = 0.9;
      await introAudio.play();
      introAudioAllowed = true;
      soundEnableBtn.style.display = 'none';
      introAudio.addEventListener('ended', () => { introAudioAllowed = false; }, { once: true });
      return true;
    } catch (err) {
      introAudioAllowed = false;
      soundEnableBtn.style.display = 'inline-block';
      return false;
    }
  }

  soundEnableBtn.addEventListener('click', async (e) => {
    e.stopPropagation();
    try {
      await introAudio.play();
      introAudioAllowed = true;
      soundEnableBtn.style.display = 'none';
      ambientAudio.volume = 0;
      ambientAudio.play().catch(()=>{});
      fadeAudio(ambientAudio, 0.28, 1500);
    } catch (err) {
      console.warn('Sound enable failed:', err);
    }
  }, { passive: true });

  function fadeAudio(audio, targetVolume, duration) {
    clearInterval(ambientFadeInterval);
    const start = isFinite(audio.volume) ? audio.volume : 0;
    const steps = Math.max(1, Math.floor(duration / 50));
    const stepDelta = (targetVolume - start) / steps;
    let stepCount = 0;
    ambientFadeInterval = setInterval(() => {
      stepCount++;
      audio.volume = Math.min(Math.max(start + stepDelta * stepCount, 0), 1);
      if (stepCount >= steps) {
        clearInterval(ambientFadeInterval);
      }
    }, 50);
  }

  function startAmbientOnInteraction() {
    if (!ambientAudio) return;
    if (ambientAudio.paused) {
      ambientAudio.volume = 0;
      ambientAudio.play().catch(() => {});
      fadeAudio(ambientAudio, 0.28, 1800);
    }
    document.removeEventListener('pointerdown', startAmbientOnInteraction);
  }

  const flickerSounds = [
    document.getElementById('flickerSound1'),
    document.getElementById('flickerSound2')
  ];

  function playFlickerSound() {
    const sound = flickerSounds[Math.floor(Math.random() * flickerSounds.length)];
    if (sound) {
      try { sound.currentTime = 0; sound.play().catch(()=>{}); } catch(e) {}
    }
  }

  function flickerLoop() {
    if (Math.random() < 0.12) {
      logo.style.setProperty('--flicker-brightness', 3 + Math.random() * 2.2);
      logo.style.textShadow = "0 0 10px #fff,0 0 40px #fff,0 0 80px rgba(255,255,255,0.85)";
      playFlickerSound();
    } else {
      logo.style.setProperty('--flicker-brightness', 0.6 + Math.random() * 0.35);
      logo.style.textShadow = "0 0 4px #fff,0 0 12px rgba(255,255,255,0.5)";
    }
    const t = setTimeout(() => {
      activeTimeouts.delete(t);
      flickerLoop();
    }, 40 + Math.random() * 180);
    activeTimeouts.add(t);
  }

  function startFlickerLoop() {
    if (!flickerLoopTimer) {
      flickerLoopTimer = true;
      flickerLoop();
    }
  }

  function stopFlickerLoop() {
    flickerLoopTimer = null;
    clearAllTrackedTimeouts();
  }

  document.querySelectorAll('button.menu-box[data-section]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const sectionId = btn.dataset.section;
      const section = document.getElementById(sectionId);
      if (!section) return;
      stage.style.opacity = 0;
      sections.forEach(s => { s.style.display = 'none'; s.setAttribute('aria-hidden', 'true'); });
      setTimeout(() => {
        section.style.display = 'flex';
        section.setAttribute('aria-hidden', 'false');
        const heading = section.querySelector('h1, h2');
        if (heading) heading.focus({preventScroll: true});
      }, 300);
    }, { passive: true });
  });

  function getFocusableElements(container) {
    const selectors = [
      'a[href]','area[href]','input:not([disabled]):not([type="hidden"])','select:not([disabled])',
      'textarea:not([disabled])','button:not([disabled])','iframe','object','embed',
      '[contenteditable]','[tabindex]:not([tabindex="-1"])'
    ];
    return Array.from(container.querySelectorAll(selectors.join(','))).filter(el => {
      return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length;
    });
  }

  function trapFocus(container) {
    const focusable = getFocusableElements(container);
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];

    modalKeyHandler = function(e) {
      if (e.key === 'Tab') {
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };
    document.addEventListener('keydown', modalKeyHandler);
  }

  function releaseFocusTrap() {
    if (modalKeyHandler) {
      document.removeEventListener('keydown', modalKeyHandler);
      modalKeyHandler = null;
    }
  }

  // Tell-me popup (kept visually unchanged if present)
  const popupEl = document.getElementById('popup');
  const closePopupEl = document.getElementById('closePopup');
  if (document.getElementById('tellBtn') && popupEl) {
    document.getElementById('tellBtn').addEventListener('click', () => {
      lastFocusedElement = document.activeElement;
      popupEl.style.display = 'flex';
      popupEl.setAttribute('aria-hidden', 'false');
      mainEl.setAttribute('aria-hidden', 'true');
      const firstControl = popupEl.querySelector('input, textarea, button');
      if (firstControl) firstControl.focus();
      trapFocus(popupEl);
    });
  }
  if (closePopupEl) closePopupEl.addEventListener('click', () => {
    popupEl.style.display = 'none';
    popupEl.setAttribute('aria-hidden', 'true');
    mainEl.setAttribute('aria-hidden', 'false');
    releaseFocusTrap();
    if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') lastFocusedElement.focus();
  });

  function onGlobalKeydown(e) {
    if (e.key !== 'Escape') return;
    if (introOverlay && introOverlay.style.display !== 'none') {
      setIntroPlayedFlag();
      hideIntroOverlay();
      return;
    }
    if (popupEl && popupEl.style.display === 'flex') {
      popupEl.style.display = 'none';
      popupEl.setAttribute('aria-hidden', 'true');
      mainEl.setAttribute('aria-hidden', 'false');
      return;
    }
    const anyVisible = sections.some(s => s.style.display === 'flex');
    if (anyVisible) goHome();
  }
  document.addEventListener('keydown', onGlobalKeydown);

  function goHome() {
    sections.forEach(s => { s.style.display = 'none'; s.setAttribute('aria-hidden', 'true'); });
    stage.style.opacity = 1;
    mainEl.setAttribute('aria-hidden', 'false');
    if (logo && typeof logo.focus === 'function') logo.focus();
  }
  window.goHome = goHome;

  async function playIntroSequence() {
    if (prefersReducedMotion() || introWasPlayed()) {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
      setIntroPlayedFlag();
      return;
    }

    introOverlay.setAttribute('aria-hidden', 'false');
    introOverlay.style.display = 'flex';

    tryPlayIntroAudio();

    const bootLines = [
      ">>> BIOS: SYNTH-8BIT v0.9.7",
      ">>> PERIPHERALS: OK  [GPU::CHIPGRID 0xFF]",
      ">>> LOADING: core.modules [████████▒▒] 80%",
      ">>> USER: WELCOME."
    ];

    for (let i = 0; i < bootLines.length; i++) {
      await typeText(bootLinesEls[i], bootLines[i], 12 + Math.random() * 8);
      await wait(140 + Math.max(0, 100 - i * 20));
      if (i === 1) {
        await grittyGlitch(bootLogo, 8, 2.6, 48);
        await wait(120);
      }
      if (i === 2) {
        await grittyGlitch(bootLinesEls[i], 10, 2.2, 42);
        await wait(110);
      }
    }

    for (let j = 0; j < 3; j++) {
      bootLogo.classList.toggle('flick');
      await wait(50 + Math.random() * 40);
    }

    await grittyGlitch(bootLogo, 10, 3.2, 36);
    flashIntro(90);

    if (introAudioAllowed && introAudio) {
      try {
        const startVol = isFinite(introAudio.volume) ? introAudio.volume : 1;
        const steps = 8;
        for (let s = 1; s <= steps; s++) {
          introAudio.volume = Math.max(0, startVol * (1 - s / steps));
          await wait(30);
        }
        try { introAudio.pause(); introAudio.currentTime = 0; } catch (err) {}
      } catch (err) {
        try { introAudio.pause(); introAudio.currentTime = 0; } catch (e) {}
      }
    }

    await wait(160);
    setIntroPlayedFlag();
    hideIntroOverlay();
    await wait(320);

    if (introAudioAllowed) {
      try {
        ambientAudio.volume = 0;
        ambientAudio.play().catch(()=>{});
        fadeAudio(ambientAudio, 0.28, 1600);
      } catch (e) {}
    } else {
      document.addEventListener('pointerdown', startAmbientOnInteraction, { once: true });
      soundEnableBtn.style.display = 'inline-block';
    }

    showMainUI();
  }

  introOverlay.addEventListener('pointerdown', (e) => {
    if (e.target === soundEnableBtn) return;
    setIntroPlayedFlag();
    hideIntroOverlay();
  }, { passive: true });

  document.addEventListener('DOMContentLoaded', () => {
    menu.style.opacity = 0;
    mainEl.setAttribute('aria-hidden', 'true');

    if (prefersReducedMotion()) {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
      setIntroPlayedFlag();
      return;
    }

    if (!introWasPlayed()) {
      playIntroSequence().catch(err => {
        console.error('Intro sequence failed:', err);
        setIntroPlayedFlag();
        introOverlay.style.display = 'none';
        showMainUI();
      });
    } else {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
    }
  });

  window.addEventListener('pagehide', () => {
    clearAllTrackedIntervals();
    clearAllTrackedTimeouts();
    try { if (introAudio && !introAudio.paused) { introAudio.pause(); } } catch (_) {}
    try { if (ambientAudio && !ambientAudio.paused) { ambientAudio.pause(); } } catch (_) {}
  }, { passive: true });

})(); /* end original site IIFE */
</script>

<!-- =========================
     GUESTBOOK: retro black+white redesign + smooth drawing + Firestore
   ========================= -->
<style>
/* Guestbook: careful retro/digital black & white aesthetic */
:root {
  --gb-bg-dark: #040404;
  --gb-panel: #0b0b0b;
  --gb-ink: #fff;
  --gb-muted: #9a9a9a;
  --gb-accent: rgba(255,255,255,0.06);
  --gb-radius: 8px;
  --gb-font: monospace;
}



.gb-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items:center; justify-content:center; z-index:1999;
}
.gb-backdrop.active { display:flex; }

.gb-modal {
  width: min(660px, calc(100% - 40px));
  max-height: calc(100vh - 80px);
  background: linear-gradient(180deg,#050505,#0b0b0b);
  color: var(--gb-ink);
  border-radius: 10px;
  box-shadow: 0 40px 120px rgba(0,0,0,0.8);
  overflow:hidden; display:flex; flex-direction:column;
  border: 1px solid rgba(255,255,255,0.04);
  font-family: var(--gb-font);
}

.gb-header {
  padding: 12px 16px;
  display:flex; align-items:center; justify-content:space-between;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  font-weight:700;
}
.gb-sub { color: var(--gb-muted); font-size:12px; margin-left:8px; font-weight:400; }

.gb-body { padding: 14px; display:flex; gap:14px; flex-direction:column; overflow:auto; }
.gb-form { display:grid; gap:10px; }

.gb-form input[type="text"], .gb-form textarea {
  width:100%; padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06);
  font-size:13px; color:var(--gb-ink); background: #020202; resize:vertical; font-family:var(--gb-font);
}
.gb-form input:focus, .gb-form textarea:focus { outline:none; box-shadow: 0 0 10px rgba(255,255,255,0.04); }

.gb-actions { display:flex; gap:8px; align-items:center; }
.gb-btn {
  background: transparent; color:var(--gb-ink); border:1px solid rgba(255,255,255,0.06); padding:8px 10px; border-radius:6px; cursor:pointer; font-weight:700;
}
.gb-btn.ghost { opacity: 0.95; }

.gb-drawer { display:none; border-radius:8px; padding:10px; background:#0f0f0f; border:1px dashed rgba(255,255,255,0.02); }
.gb-drawer.active { display:block; }

.gb-canvas-wrap { display:flex; gap:12px; align-items:center; justify-content:center; }
.gb-canvas {
  width: 360px; height: 220px;
  border-radius:6px; background: #080808; border: 2px solid rgba(255,255,255,0.04);
  image-rendering: pixelated; touch-action: none;
  display:block;
}
.gb-tools { display:flex; gap:8px; align-items:center; }

.gb-tool {
  padding:8px 10px; border-radius:6px; background:#0b0b0b; color:#fff; border:1px solid rgba(255,255,255,0.04); cursor:pointer; font-family:var(--gb-font);
}
.gb-tool:hover { background:#121212; }

.gb-messages { display:flex; gap:10px; flex-direction:column; }
.gb-msg { display:flex; gap:12px; align-items:flex-start; padding:10px; border-bottom:1px solid rgba(255,255,255,0.03); }
.gb-msg .meta { font-size:12px; color:var(--gb-muted); margin-bottom:6px; display:flex; justify-content:space-between; width:100%; }
.gb-msg .content { white-space:pre-wrap; font-size:14px; color:var(--gb-ink); font-family:var(--gb-font); }
.gb-msg img { max-width:200px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); image-rendering: pixelated; }

.gb-footer { padding:10px; border-top:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center; gap:8px; }
.gb-muted { color:var(--gb-muted); font-size:12px; }

@media (max-width:520px){
  .gb-modal { width: calc(100% - 24px) }
  .gb-canvas { width:260px; height:160px }
}
</style>

<!-- Guestbook trigger -->


<!-- Guestbook modal -->
<div class="gb-backdrop" id="gbBackdrop" aria-hidden="true">
  <div class="gb-modal" role="dialog" aria-modal="true" aria-label="Guestbook">
    <div class="gb-header">
      <div style="display:flex;align-items:center;gap:10px;">
        <div style="font-weight:700">Guestbook</div>
        <div class="gb-sub">retro digital — black & white</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="gbAdminBtn" class="gb-tool" title="Admin (delete)">⚙️</button>
        <button id="gbCloseBtn" class="gb-tool" title="Close">✕</button>
      </div>
    </div>

    <div class="gb-body">
      <form id="gbForm" class="gb-form" onsubmit="return false;">
        <input id="gbName" type="text" placeholder="Your name (optional)" maxlength="60" />
        <textarea id="gbMessage" rows="3" placeholder="Write a message (optional, 300 chars max)" maxlength="300"></textarea>

        <div class="gb-actions">
          <button id="gbToggleDraw" type="button" class="gb-btn ghost">Add drawing</button>
          <button id="gbSubmit" type="button" class="gb-btn">Submit</button>
          <div style="flex:1"></div>
          <div class="gb-muted" id="gbCount">0 messages</div>
        </div>

        <div class="gb-drawer" id="gbDrawer" aria-hidden="true">
          <div class="gb-canvas-wrap">
            <canvas id="gbCanvas" class="gb-canvas" width="720" height="440" aria-label="Drawing canvas"></canvas>
            <div class="gb-tools" role="toolbar" aria-label="Canvas tools">
              <input id="gbColor" type="color" value="#ffffff" title="Color" style="width:36px;height:36px;border-radius:6px;border:0;padding:0;margin-bottom:6px" />
              <button id="gbBrushSmall" class="gb-tool" title="Small brush">S</button>
              <button id="gbBrushMed" class="gb-tool" title="Medium brush">M</button>
              <button id="gbBrushLarge" class="gb-tool" title="Large brush">L</button>
              <button id="gbUndo" class="gb-tool" title="Undo">↶</button>
              <button id="gbClear" class="gb-tool" title="Clear">⤾</button>
            </div>
          </div>
          <div style="font-size:12px;color:var(--gb-muted);margin-top:8px">Draw a compact note — it will be attached to your post.</div>
        </div>
      </form>

      <div class="gb-messages" id="gbMessages" aria-live="polite"></div>
    </div>

    <div class="gb-footer">
      <div class="gb-muted">Public · visible to everyone</div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="gbClearLocal" class="gb-tool" title="Clear local">Clear local</button>
      </div>
    </div>
  </div>
</div>

<!-- Firebase & Guestbook Script -->
<script type="module">
/* Firestore guestbook integration + smooth drawing
   - Uses your firebase config (unchanged)
   - Admin delete unlocked via password 'indobingo'
   - Smooth drawing using pointer events, smoothing and rAF
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics.js";
import {
  getFirestore, collection, addDoc, serverTimestamp,
  onSnapshot, query, orderBy, limit, doc, deleteDoc
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

/* ========== YOUR FIREBASE CONFIG (kept exactly as you provided) ========== */
const firebaseConfig = {
  apiKey: "AIzaSyBeXCRIeRdHr2C3EYnDwC1NoQNQxZygA0U",
  authDomain: "guestbook-bfbdc.firebaseapp.com",
  databaseURL: "https://guestbook-bfbdc-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "guestbook-bfbdc",
  storageBucket: "guestbook-bfbdc.firebasestorage.app",
  messagingSenderId: "710789947600",
  appId: "1:710789947600:web:19014ef99d053f4c5dbed5",
  measurementId: "G-E9XPN9563X"
};

const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e){ /* noop if analytics blocked */ }
const db = getFirestore(app);

/* ========== DOM refs ========== */
const gbTrigger = document.getElementById('gbTrigger');
const gbBackdrop = document.getElementById('gbBackdrop');
const gbCloseBtn = document.getElementById('gbCloseBtn');
const gbAdminBtn = document.getElementById('gbAdminBtn');

const gbForm = document.getElementById('gbForm');
const gbName = document.getElementById('gbName');
const gbMessage = document.getElementById('gbMessage');
const gbToggleDraw = document.getElementById('gbToggleDraw');
const gbDrawer = document.getElementById('gbDrawer');
const gbCanvas = document.getElementById('gbCanvas');
const gbColor = document.getElementById('gbColor');
const gbBrushSmall = document.getElementById('gbBrushSmall');
const gbBrushMed = document.getElementById('gbBrushMed');
const gbBrushLarge = document.getElementById('gbBrushLarge');
const gbUndo = document.getElementById('gbUndo');
const gbClear = document.getElementById('gbClear');
const gbSubmit = document.getElementById('gbSubmit');
const gbMessages = document.getElementById('gbMessages');
const gbCount = document.getElementById('gbCount');
const gbClearLocal = document.getElementById('gbClearLocal');

const ADMIN_PASSWORD = 'indobingo';

/* ========== Modal open/close ========== */
function openGB() {
  gbBackdrop.classList.add('active');
  gbBackdrop.setAttribute('aria-hidden','false');
  // ensure drawer closed by default
  // (we keep it closed until user toggles)
}
function closeGB() {
  gbBackdrop.classList.remove('active');
  gbBackdrop.setAttribute('aria-hidden','true');
}
gbTrigger.addEventListener('click', openGB);
gbCloseBtn.addEventListener('click', closeGB);
gbBackdrop.addEventListener('click', (e) => { if (e.target === gbBackdrop) closeGB(); });

/* ========== Admin toggle ========== */
gbAdminBtn.addEventListener('click', () => {
  const ok = sessionStorage.getItem('gb_admin_authenticated') === '1';
  if (ok) {
    sessionStorage.removeItem('gb_admin_authenticated');
    alert('Admin disabled for this session.');
    renderMessages(currentDocs);
    return;
  }
  const p = prompt('Enter admin password:');
  if (p === ADMIN_PASSWORD) {
    sessionStorage.setItem('gb_admin_authenticated','1');
    alert('Admin enabled. Delete buttons available.');
    renderMessages(currentDocs);
  } else {
    alert('Wrong password.');
  }
});

/* ========== Drawing engine (smooth with smoothing/webrtc-style interpolation) ========== */
const ctx = gbCanvas.getContext('2d', { alpha: false });
let dpr = Math.max(1, window.devicePixelRatio || 1);
let canvasW = 720, canvasH = 440;
let isDrawing = false;
let lastPoints = [];        // for smoothing
let strokeHistory = [];     // undo stack: array of strokes {points, color, size}
let currentStroke = null;
let brushColor = '#ffffff';
let brushSize = 3;
let rafPending = false;
let pendingDrawQueue = [];

/* Resize canvas to CSS pixels * devicePixelRatio and preserve content */
function resizeCanvasToDisplay() {
  const rect = gbCanvas.getBoundingClientRect();
  // Prefer fixed aspect to keep pixelated look: scale internal buffer to rect * dpr
  const cssW = Math.max(240, Math.floor(rect.width));
  const cssH = Math.max(140, Math.floor(rect.height));
  // create temp copy
  const tmp = document.createElement('canvas');
  tmp.width = gbCanvas.width;
  tmp.height = gbCanvas.height;
  tmp.getContext('2d').drawImage(gbCanvas, 0, 0);
  gbCanvas.width = Math.floor(cssW * dpr);
  gbCanvas.height = Math.floor(cssH * dpr);
  gbCanvas.style.width = cssW + 'px';
  gbCanvas.style.height = cssH + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  // fill background
  ctx.fillStyle = '#0b0b0b';
  ctx.fillRect(0,0, cssW, cssH);
  // draw previous
  if (tmp.width && tmp.height) {
    ctx.drawImage(tmp, 0, 0, cssW, cssH);
  }
}
window.addEventListener('resize', () => { dpr = Math.max(1, window.devicePixelRatio || 1); resizeCanvasToDisplay(); });
resizeCanvasToDisplay();

/* Utility: pointer position relative to canvas */
function pointerPos(e) {
  const rect = gbCanvas.getBoundingClientRect();
  const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
  const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
  return { x: clientX - rect.left, y: clientY - rect.top, t: Date.now() };
}

/* Add point to smoothing buffer and schedule draw */
function addPoint(pt) {
  pendingDrawQueue.push(pt);
  if (!rafPending) {
    rafPending = true;
    requestAnimationFrame(flushPending);
  }
}

/* Simple smoothing algorithm: moving average + quadratic curve drawing */
function flushPending() {
  rafPending = false;
  if (!pendingDrawQueue.length) return;
  // append points to currentStroke if drawing
  if (isDrawing && currentStroke) {
    currentStroke.points.push(...pendingDrawQueue.map(p => ({x:p.x, y:p.y})));
  }

  // draw immediately with smoothing
  const pts = pendingDrawQueue.splice(0);
  drawSmoothed(pts, brushColor, brushSize);
}

/* Draw smoothed line from points */
function drawSmoothed(points, color, size) {
  if (!points || !points.length) return;
  ctx.save();
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.strokeStyle = color;
  ctx.lineWidth = size;
  // If single point, draw a dot
  if (points.length === 1) {
    const p = points[0];
    ctx.beginPath();
    ctx.arc(p.x, p.y, size/2, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
    return;
  }
  // If short sequence, draw simple quadratic smoothing across them
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length - 1; i++) {
    const midX = (points[i].x + points[i+1].x) / 2;
    const midY = (points[i].y + points[i+1].y) / 2;
    ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
  }
  const last = points[points.length - 1];
  ctx.lineTo(last.x, last.y);
  ctx.stroke();
  ctx.restore();
}

/* Pointer handlers */
function pointerDownHandler(e) {
  e.preventDefault();
  gbCanvas.setPointerCapture && gbCanvas.setPointerCapture(e.pointerId);
  isDrawing = true;
  const p = pointerPos(e);
  currentStroke = { points: [{x:p.x, y:p.y}], color: brushColor, size: brushSize };
  addPoint({x:p.x, y:p.y});
}
function pointerMoveHandler(e) {
  if (!isDrawing) return;
  const p = pointerPos(e);
  // avoid too-dense points
  const last = currentStroke && currentStroke.points.length ? currentStroke.points[currentStroke.points.length-1] : null;
  if (last && Math.hypot(p.x - last.x, p.y - last.y) < 0.5) return;
  addPoint({x:p.x, y:p.y});
}
function pointerUpHandler(e) {
  if (!isDrawing) return;
  isDrawing = false;
  // commit stroke to history
  if (currentStroke && currentStroke.points && currentStroke.points.length) {
    strokeHistory.push(currentStroke);
    currentStroke = null;
  }
}

/* Attach pointer events */
gbCanvas.addEventListener('pointerdown', pointerDownHandler, { passive:false });
gbCanvas.addEventListener('pointermove', pointerMoveHandler, { passive:false });
gbCanvas.addEventListener('pointerup', pointerUpHandler, { passive:false });
gbCanvas.addEventListener('pointercancel', pointerUpHandler, { passive:false });
gbCanvas.addEventListener('touchstart', (e)=>{ /* allow pointer events to handle this */ }, {passive:true});

/* Tool controls */
gbColor.addEventListener('input', (e) => { brushColor = e.target.value || '#ffffff'; });
gbBrushSmall.addEventListener('click', () => { brushSize = 2; });
gbBrushMed.addEventListener('click', () => { brushSize = 4; });
gbBrushLarge.addEventListener('click', () => { brushSize = 8; });

gbUndo.addEventListener('click', () => {
  if (!strokeHistory.length) return;
  strokeHistory.pop();
  redrawAll();
});
gbClear.addEventListener('click', () => {
  if (!confirm('Clear drawing?')) return;
  strokeHistory = [];
  redrawAll();
});

/* Redraw all strokes from history */
function redrawAll() {
  const cssW = gbCanvas.clientWidth;
  const cssH = gbCanvas.clientHeight;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.fillStyle = '#0b0b0b';
  ctx.fillRect(0,0, cssW, cssH);
  for (const s of strokeHistory) {
    drawSmoothed(s.points, s.color, s.size);
  }
}

/* Toggle drawer */
let drawerOpen = false;
gbToggleDraw.addEventListener('click', () => {
  drawerOpen = !drawerOpen;
  gbDrawer.classList.toggle('active', drawerOpen);
  gbToggleDraw.textContent = drawerOpen ? 'Hide drawing' : 'Add drawing';
  // when opening, ensure canvas fits the CSS area
  if (drawerOpen) {
    setTimeout(() => { resizeCanvasToDisplay(); redrawAll(); }, 60);
  }
});

/* Export drawing as PNG dataURL (scaled down to max 640px width) */
function exportDrawingDataUrl(maxWidth = 640) {
  if (!strokeHistory.length) return null;
  // draw to temp canvas at desired pixel size
  const cssW = gbCanvas.clientWidth;
  const cssH = gbCanvas.clientHeight;
  let scale = 1;
  if (cssW > maxWidth) scale = maxWidth / cssW;
  const tmp = document.createElement('canvas');
  tmp.width = Math.floor(cssW * scale);
  tmp.height = Math.floor(cssH * scale);
  const tctx = tmp.getContext('2d');
  // black/dark background
  tctx.fillStyle = '#0b0b0b';
  tctx.fillRect(0,0,tmp.width,tmp.height);
  // draw strokes scaled
  for (const s of strokeHistory) {
    tctx.save();
    tctx.lineJoin = 'round';
    tctx.lineCap = 'round';
    tctx.strokeStyle = s.color;
    tctx.lineWidth = s.size * scale;
    tctx.beginPath();
    const pts = s.points;
    if (pts.length === 1) {
      const p = pts[0]; tctx.arc(p.x*scale, p.y*scale, (s.size/2)*scale, 0, Math.PI*2);
      tctx.fillStyle = s.color; tctx.fill();
      tctx.restore();
      continue;
    }
    tctx.moveTo(pts[0].x*scale, pts[0].y*scale);
    for (let i=1;i<pts.length-1;i++){
      const midX = (pts[i].x + pts[i+1].x)/2;
      const midY = (pts[i].y + pts[i+1].y)/2;
      tctx.quadraticCurveTo(pts[i].x*scale, pts[i].y*scale, midX*scale, midY*scale);
    }
    const last = pts[pts.length-1];
    tctx.lineTo(last.x*scale, last.y*scale);
    tctx.stroke();
    tctx.restore();
  }
  return tmp.toDataURL('image/png', 0.92);
}

/* ========== Firestore guestbook logic ========== */
const gbCollection = collection(db, 'guestbook');

/* Real-time listener: last 200 entries (newest first) */
const q = query(gbCollection, orderBy('timestamp', 'desc'), limit(200));
let currentDocs = [];
onSnapshot(q, snap => {
  const docs = [];
  snap.forEach(d => docs.push({ id: d.id, data: d.data() }));
  currentDocs = docs;
  renderMessages(docs);
}, err => {
  console.error('Guestbook snapshot error', err);
});

/* Render messages */
function renderMessages(docs) {
  gbMessages.innerHTML = '';
  let count = 0;
  const isAdmin = sessionStorage.getItem('gb_admin_authenticated') === '1';
  docs.forEach(item => {
    const d = item.data || item.data;
    count++;
    const wrapper = document.createElement('div');
    wrapper.className = 'gb-msg';

    const left = document.createElement('div');
    left.style.flex = '1';

    const meta = document.createElement('div');
    meta.className = 'meta';
    const nameEl = document.createElement('div');
    nameEl.textContent = d.name || 'anon';
    const timeEl = document.createElement('div');
    let timeText = '';
    if (d.timestamp && d.timestamp.toDate) timeText = d.timestamp.toDate().toLocaleString();
    else if (d.timestamp) timeText = new Date(d.timestamp).toLocaleString();
    timeEl.textContent = timeText;
    meta.appendChild(nameEl);
    meta.appendChild(timeEl);

    const content = document.createElement('div');
    content.className = 'content';
    content.textContent = d.message || '';

    left.appendChild(meta);
    left.appendChild(content);

    if (d.drawing) {
      const img = document.createElement('img');
      img.src = d.drawing;
      img.alt = 'Drawing';
      img.loading = 'lazy';
      img.style.marginTop = '8px';
      left.appendChild(img);
    }

    const controls = document.createElement('div');
    controls.style.display = 'flex';
    controls.style.flexDirection = 'column';
    controls.style.gap = '6px';

    const copyBtn = document.createElement('button');
    copyBtn.className = 'gb-tool';
    copyBtn.textContent = 'Copy';
    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(d.message || '');
        copyBtn.textContent = 'Copied';
        setTimeout(()=> copyBtn.textContent = 'Copy', 1200);
      } catch (e) { /* ignore */ }
    });
    controls.appendChild(copyBtn);

    if (isAdmin) {
      const delBtn = document.createElement('button');
      delBtn.className = 'gb-tool';
      delBtn.textContent = 'Delete';
      delBtn.style.background = '#180808';
      delBtn.style.color = '#ffbdbd';
      delBtn.addEventListener('click', async () => {
        if (!confirm('Delete this entry?')) return;
        try {
          await deleteDoc(doc(db, 'guestbook', item.id));
        } catch (err) {
          alert('Delete failed: ' + (err && err.message ? err.message : err));
        }
      });
      controls.appendChild(delBtn);
    }

    wrapper.appendChild(left);
    wrapper.appendChild(controls);
    gbMessages.appendChild(wrapper);
  });
  gbCount.textContent = `${count} ${count === 1 ? 'message' : 'messages'}`;
}

/* Submit event */
gbSubmit.addEventListener('click', async () => {
  gbSubmit.disabled = true;
  const name = (gbName.value || '').trim() || 'anon';
  const message = (gbMessage.value || '').trim() || '';
  let drawingData = null;
  try {
    drawingData = exportDrawingDataUrl(720);
  } catch (err) {
    console.warn('Export failed', err);
    drawingData = null;
  }
  if (!name && !message && !drawingData) {
    alert('Please add a name, a message, or a drawing.');
    gbSubmit.disabled = false;
    return;
  }
  try {
    await addDoc(gbCollection, {
      name,
      message,
      drawing: drawingData || null,
      timestamp: serverTimestamp()
    });
    // feedback and reset
    gbMessage.value = '';
    gbName.value = '';
    gbSubmit.textContent = 'Sent ✓';
    setTimeout(()=> gbSubmit.textContent = 'Submit', 1200);
  } catch (err) {
    console.error('Submit failed', err);
    alert('Failed to submit: ' + (err && err.message ? err.message : err));
  }
  gbSubmit.disabled = false;
});

/* Clear local list */
gbClearLocal.addEventListener('click', () => {
  if (!confirm('Clear local message list? This does not delete server data.')) return;
  gbMessages.innerHTML = '';
  gbCount.textContent = '0 messages';
});

/* Small helper: load doc symbol (doc function) for delete calls */
const { doc: _doc } = await import('https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js').catch(()=>({}));

/* Done */
</script>

</body>
</html>
