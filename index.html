<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>synt — everything feels different in the dark</title>
<meta name="description" content="synt — ambient sounds and visuals. Everything feels different in the dark.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="synt — everything feels different in the dark">
<meta property="og:description" content="synt — ambient sounds and visuals. Everything feels different in the dark.">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<style>
:root{
  --bg: #0a0a0a;
  --fg: #ffffff;
  --card-bg: #111;
  --input-bg: #000;
  --input-border: #444;
  --accent: rgba(255,255,255,0.06);
  --success: #0f0;
  --error: #ff5c5c;

  --border-width: 2px;
  --border-color: var(--fg);

  --page-padding: clamp(1rem, 3vw, 2.25rem);
  --max-content-width: 1200px;
  --stage-offset: 3.2vh;
  --stage-gap: 1.05rem;
  --logo-byline-gap: 0.18rem;
  --byline-menu-gap: 0.7rem;

  --menu-gap: 0.72rem;
  --menu-padding-vertical: 0.85rem;
  --menu-padding-horizontal: 1.6rem;
  --menu-min-width: 120px;

  --control-padding: 0.5rem;

  --font-family: monospace, ui-monospace, "SFMono-Regular", Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
  --byline-size: 0.95rem;

  --shadow-small: 0 0 6px #fff;
  --shadow-medium: 0 0 18px #fff;
  --shadow-large: 0 0 40px rgba(255,255,255,0.6);

  --flicker-brightness: 1;
}

/* Base */
html,body {
  height: 100%;
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--fg);
  font-family: var(--font-family);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overflow: hidden;
}

/* Accessibility helper */
.visually-hidden {
  position: absolute !important;
  width: 1px; height: 1px;
  overflow: hidden;
  clip: rect(1px,1px,1px,1px);
  white-space: nowrap;
}

/* Skip link */
.skip-link {
  position: absolute;
  left: -9999px;
  width: 1px; height: 1px; overflow: hidden;
}
.skip-link:focus {
  left: 1rem; top: 1rem;
  width: auto; height: auto;
  padding: .5rem 1rem;
  background: #222; color: var(--fg);
  z-index: 9999; text-decoration: none; border-radius: 6px;
}

/* Strong film grain for grittier look */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background:
    repeating-linear-gradient(to bottom, rgba(255,255,255,0.03) 0 1px, transparent 1px 3px),
    radial-gradient(circle at 30% 20%, rgba(255,255,255,0.01), transparent 10%),
    radial-gradient(circle at 70% 80%, rgba(255,255,255,0.01), transparent 8%);
  pointer-events: none;
  z-index: 5;
  mix-blend-mode: overlay;
  opacity: 0.95;
}

/* Main centering */
main#main {
  min-height: 100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  padding: var(--page-padding);
  position: relative;
}

/* ---------- INTRO OVERLAY (monochrome & gritty) ---------- */
.intro-overlay {
  position: fixed;
  inset: 0;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  flex-direction: column;
  color: #fff; /* strictly white text */
  font-family: var(--font-family);
  text-align: center;
  gap: 0.8rem;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* noise and pixel textures */
.intro-noise {
  position: absolute; inset: 0;
  background-image:
    radial-gradient(circle at 10% 20%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    radial-gradient(circle at 80% 30%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    radial-gradient(circle at 40% 70%, rgba(255,255,255,0.02) 0 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.015) 0 1px, transparent 1px 2px);
  background-size: 6px 6px, 6px 6px, 6px 6px, 4px 4px;
  opacity: 0.12;
  pointer-events: none;
  mix-blend-mode: screen;
}

/* scan sweep faster */
.scanline {
  position: absolute;
  left: -10%;
  width: 120%;
  height: 28vh;
  top: -40%;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  transform: skewY(-10deg);
  opacity: 0.06;
  filter: blur(6px) contrast(120%);
  animation: sweep 1.6s linear 0s 1;
  pointer-events: none;
  mix-blend-mode: screen;
}
@keyframes sweep { to { transform: translateY(240%) skewY(-10deg); opacity: 0; } }

.scan-vert {
  position: absolute; inset: 0;
  background-image: linear-gradient(90deg, rgba(255,255,255,0.012) 0 1px, transparent 1px 3px);
  opacity: 0.045;
  pointer-events: none;
  mix-blend-mode: screen;
}

.pixel-grid {
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(transparent 0 95%, rgba(255,255,255,0.01) 95% 100%),
    linear-gradient(90deg, transparent 0 95%, rgba(255,255,255,0.01) 95% 100%);
  background-size: 6px 6px, 6px 6px;
  opacity: 0.08;
  pointer-events: none;
  mix-blend-mode: screen;
}

/* flash overlay */
.intro-flash {
  position: absolute; inset: 0;
  background: white;
  opacity: 0;
  pointer-events: none;
}

/* Boot text - monochrome, bold */
.boot {
  z-index: 1000;
  max-width: 80ch;
  font-size: clamp(0.95rem, 1.9vw, 1.1rem);
  line-height: 1.18;
  text-align: left;
  color: #fff;
  letter-spacing: 0.02em;
  filter: drop-shadow(0 0 6px rgba(255,255,255,0.06));
  transform: translateZ(0);
  font-weight: 700;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: none;
}
.boot-line { display:block; white-space: pre; font-variant-numeric: tabular-nums; }

/* glitch logo (monochrome duplicates for roughness) */
.glitch {
  position: relative;
  display: inline-block;
  color: #fff;
  font-weight: 900;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  font-size: 0.9rem;
  filter: drop-shadow(0 0 6px rgba(255,255,255,0.06));
}
.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute; left: 0; top: 0; width: 100%;
  pointer-events: none;
  color: #fff;
  opacity: 0.9;
  mix-blend-mode: normal;
}
.glitch::before { transform: translateX(-1px) translateY(-1px) scale(1.003); opacity: 0.6; }
.glitch::after  { transform: translateX(1px) translateY(1px) scale(0.997); opacity: 0.5; }

/* small sound enable button (only shown if audio blocked) */
.sound-enable {
  position: absolute;
  top: 12px;
  right: 12px;
  z-index: 1010;
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.12);
  padding: .35rem .6rem;
  font-family: var(--font-family);
  cursor: pointer;
  border-radius: 6px;
  font-size: .85rem;
  backdrop-filter: blur(4px);
  display: none;
}
.sound-enable:active { transform: translateY(1px); }

/* ---------- STAGE (site) ---------- */
.stage {
  width: min(var(--max-content-width), 100%);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: var(--stage-gap);
  position: relative; z-index: 10;
  opacity: 1;
  transition: opacity .35s ease, transform .35s ease;
  transform: translateY(var(--stage-offset));
}

.logo {
  font-size: clamp(4rem, 18vw, 14rem);
  font-weight: bold;
  text-transform: uppercase;
  color: var(--fg);
  filter: brightness(var(--flicker-brightness));
  text-shadow: var(--shadow-small), var(--shadow-medium), var(--shadow-large);
  transition: filter .1s ease, text-shadow .1s ease;
  letter-spacing: -0.05em;
  font-kerning: normal;
  text-rendering: optimizeLegibility;
  margin: 0;
}

.byline {
  font-size: var(--byline-size);
  opacity: 0.65;
  margin: 0;
  padding-top: var(--logo-byline-gap);
  letter-spacing: 0.18em;
}

.menu {
  display:flex;
  gap: var(--menu-gap);
  margin-top: var(--byline-menu-gap);
  justify-content:center;
  flex-wrap:wrap;
  opacity: 0;
  transition: opacity .6s ease;
}

.menu-box {
  background: transparent;
  color: var(--fg);
  border: var(--border-width) solid var(--border-color);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  padding: var(--menu-padding-vertical) var(--menu-padding-horizontal);
  font-family: inherit;
  font-size: inherit;
  text-align: center;
  -webkit-appearance: none;
  -moz-appearance: none;
  border-radius: 6px;
  min-width: var(--menu-min-width);
}
.menu-box::after {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--accent);
  transform: translateY(100%);
  transition: transform .22s ease;
  pointer-events: none;
}
.menu-box:hover::after { transform: translateY(0); }
.menu-box:hover { filter: brightness(1.4); }

/* Popup + sections */
.popup {
  position: fixed; inset: 0; background: rgba(0,0,0,0.9);
  display: none; flex-direction: column; align-items: center; justify-content:center; z-index:100;
}
.popup form {
  display:flex; flex-direction:column; gap:1rem; background:var(--card-bg); padding:2rem; border:var(--border-width) solid var(--border-color); width:320px; border-radius:8px;
}
.popup input, .popup textarea { background:var(--input-bg); color:var(--fg); border:1px solid var(--input-border); padding:var(--control-padding); font-family:var(--font-family); border-radius:6px; }
.popup button[type="submit"] { background:var(--fg); color:var(--bg); border:none; padding:.6rem; cursor:pointer; font-weight:bold; border-radius:6px; }
.form-status { font-size:.9rem; color:var(--success); }

.section { position:fixed; inset:0; background:var(--bg); display:none; flex-direction:column; align-items:center; padding:2rem; overflow-y:auto; z-index:90; }
.section h1 { text-transform:uppercase; margin-bottom:2rem; }
.grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:1rem; width:100%; max-width:var(--max-content-width); }
.track, .visual { background:var(--card-bg); padding:1rem; border:var(--border-width) solid var(--border-color); border-radius:6px; }
.track audio { width:100% } .visual img { width:100%; height:auto; display:block; }

.back-btn { margin-top:2rem; cursor:pointer; text-transform:uppercase; letter-spacing:.1em; border:var(--border-width) solid var(--border-color); padding:.5rem 1rem; background:transparent; color:var(--fg); border-radius:6px; }
.back-btn:hover { filter:brightness(1.4); }

/* Responsive */
@media (max-width:880px){ :root{--stage-offset:3vh;--stage-gap:0.9rem} .menu-box{min-width:100px;padding-inline:1.25rem} }
@media (max-width:520px){ :root{--stage-offset:2vh} .logo{font-size:clamp(2.2rem,14vw,6.6rem);letter-spacing:-0.03em} .menu{gap:0.45rem;margin-top:0.45rem} .menu-box{min-width:84px;padding:.7rem 1rem;font-size:.95rem} .popup form{width:92%;max-width:420px;padding:1rem} }

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .stage, .menu-box, .menu-box::after, body::before, .scanline, .intro-overlay { transition: none !important; animation: none !important; }
}

/* Guestbook specific styles (kept same look) */
:root {
  --gb-bg: var(--card-bg);
  --gb-text: var(--fg);
  --gb-accent: var(--accent);
  --gb-muted: rgba(255,255,255,0.36);
  --gb-radius: 8px;
  --gb-shadow: 0 18px 60px rgba(0,0,0,0.7);
  --gb-font: var(--font-family);
  --gb-line: rgba(255,255,255,0.04);
}

.gb-trigger {
  position: fixed;
  right: 18px;
  bottom: 18px;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  display:flex; align-items:center; justify-content:center;
  background: rgba(255,255,255,0.02);
  color: var(--gb-text);
  cursor:pointer;
  z-index: 1500;
  opacity: 0.22;
  transition: opacity .18s ease, transform .12s ease;
  border: 1px solid rgba(255,255,255,0.03);
  backdrop-filter: blur(3px);
  font-family: var(--gb-font);
}
.gb-trigger:hover { opacity:0.95; transform: translateY(-2px); }

.gb-backdrop {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.6);
  display: none; align-items:center; justify-content:center;
  z-index:1499;
}
.gb-backdrop.active { display:flex; }

.gb-modal {
  width: min(520px, calc(100% - 40px));
  max-height: calc(100vh - 80px);
  border-radius: var(--gb-radius);
  background: var(--gb-bg);
  color: var(--gb-text);
  box-shadow: var(--gb-shadow);
  overflow:hidden;
  display:flex; flex-direction:column;
  font-family: var(--gb-font);
  border: 1px solid rgba(255,255,255,0.04);
}

.gb-header {
  padding:12px 14px; display:flex; align-items:center; justify-content:space-between;
  border-bottom: 1px solid rgba(255,255,255,0.03);
  font-weight:700; font-size:14px;
}
.gb-sub { color: var(--gb-muted); font-size:12px; font-weight:400; margin-left:8px; }

.gb-close, .gb-admin-toggle {
  background:transparent;border:0;color:var(--gb-muted);cursor:pointer;padding:8px;border-radius:6px;
}
.gb-close:hover, .gb-admin-toggle:hover { color:var(--gb-text); background: rgba(255,255,255,0.02); }

.gb-body { padding:12px; overflow:auto; display:flex; gap:12px; flex-direction:column; }

.gb-form { display:grid; gap:8px; }
.gb-form input[type="text"], .gb-form textarea {
  width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04);
  font-size:13px; color:var(--gb-text); background: rgba(255,255,255,0.01); resize:vertical; font-family: var(--gb-font);
}
.gb-actions { display:flex; gap:8px; align-items:center; }
.gb-btn { background: var(--gb-accent); color: var(--gb-text); border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }
.gb-btn.ghost { background:transparent; color:var(--gb-text); border:1px solid rgba(255,255,255,0.04); }

.gb-drawer { display:none; border-radius:8px; border:1px dashed rgba(255,255,255,0.03); padding:8px; background: rgba(255,255,255,0.01); }
.gb-drawer.active { display:block; }

.gb-canvas-wrap { display:flex; gap:8px; align-items:flex-start; }
.gb-canvas { border:1px solid rgba(255,255,255,0.03); border-radius:6px; background:#fff; touch-action:none; }
.gb-tools { display:flex; gap:6px; flex-direction:column; align-items:center; }
.gb-tool { padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--gb-text); cursor:pointer; font-size:12px; }

.gb-messages { display:flex; gap:10px; flex-direction:column; }
.gb-msg { border-radius:8px; padding:10px; background:transparent; display:flex; gap:10px; align-items:flex-start; border-bottom:1px solid var(--gb-line); }
.gb-msg .meta { font-size:12px; color:var(--gb-muted); margin-bottom:6px; display:flex; justify-content:space-between; gap:8px; align-items:center; width:100%; }
.gb-msg .content { white-space:pre-wrap; font-size:14px; color:var(--gb-text); font-family:var(--gb-font); }
.gb-msg img { max-width:160px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); }
.gb-msg .controls { display:flex; gap:6px; align-items:center; }
.gb-msg button.copy { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--gb-text); padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
.gb-msg button.del { background:transparent; border:0; color:#ff7a7a; cursor:pointer; padding:6px; font-size:12px; border-radius:6px; }

.gb-footer { padding:10px; border-top:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center; gap:8px; }
.gb-muted { color:var(--gb-muted); font-size:12px; }

@media (max-width:520px){
  .gb-modal { width: calc(100% - 24px); }
  .gb-canvas { width: 220px; height:150px; }
  .gb-msg img { max-width:120px; }
}
</style>
</head>
<body>
  <a href="#main" class="skip-link">Skip to content</a>

  <!-- Intro overlay -->
  <div id="intro" class="intro-overlay" aria-hidden="true" role="dialog" aria-label="Startup">
    <div class="intro-noise" aria-hidden="true"></div>
    <div class="scanline" aria-hidden="true"></div>
    <div class="scan-vert" aria-hidden="true"></div>
    <div class="pixel-grid" aria-hidden="true"></div>
    <div class="intro-flash" id="introFlash" aria-hidden="true"></div>

    <!-- optional small button to enable sound if browser blocks autoplay -->
    <button id="soundEnableBtn" class="sound-enable" aria-hidden="true">Enable sound</button>

    <div class="boot" id="bootText" aria-hidden="false" role="status" aria-live="polite">
      <span class="boot-line" id="line1"></span>
      <span class="boot-line" id="line2"></span>
      <span class="boot-line" id="line3"></span>
      <span class="boot-line" id="line4"></span>
    </div>

    <div style="font-size:.85rem;opacity:.95;color:#fff;margin-top:6vh">
      <span class="glitch" id="bootLogo" data-text="S Y N T">S Y N T</span>
    </div>
  </div>

  <main id="main" aria-hidden="false">
    <header class="stage" id="stage" role="banner" aria-hidden="false">
      <h1 id="logo" class="logo" tabindex="-1">synt</h1>
      <p class="byline">everything feels different in the dark</p>

      <nav class="menu" id="menu" aria-label="Primary">
        <button class="menu-box" data-section="sounds" type="button">Sounds</button>
        <button class="menu-box" data-section="visuals" type="button">Visuals</button>
        <button class="menu-box" id="tellBtn" type="button">Tell me something</button>
        <!-- Embedded synth button (added) -->
        <button class="menu-box" id="synthBtn" type="button" aria-controls="synthOverlay" aria-expanded="false">Make some noise</button>
      </nav>
    </header>

    <!-- Popup Form -->
    <div class="popup" id="popup" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="tell-heading">
      <form id="tellMeForm" action="https://formspree.io/f/meozvvon" method="POST" novalidate>
        <h2 id="tell-heading" class="visually-hidden">Send a message</h2>

        <label class="visually-hidden" for="name">Your name</label>
        <input id="name" type="text" name="name" placeholder="Your name" required aria-required="true">

        <label class="visually-hidden" for="message">Your message</label>
        <textarea id="message" rows="4" name="message" placeholder="Your message" required aria-required="true"></textarea>

        <button type="submit">Send</button>
        <p id="formStatus" class="form-status" role="status" aria-live="polite"></p>

        <button class="back-btn" id="closePopup" type="button">Close</button>
      </form>
    </div>

    <!-- Sounds Section -->
    <section class="section" id="sounds" role="region" aria-labelledby="sounds-heading" aria-hidden="true">
      <h1 id="sounds-heading" tabindex="-1">Sounds</h1>
      <div class="grid">
        <div class="track">
          <strong>Track 1</strong>
          <audio controls preload="none">
            <source src="your-audio.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
          </audio>
        </div>
        <div class="track">
          <strong>Track 2</strong>
          <audio controls preload="none">
            <source src="your-audio2.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
          </audio>
        </div>
      </div>
      <button class="back-btn" type="button" onclick="goHome()">Back</button>
    </section>

    <!-- Visuals Section -->
    <section class="section" id="visuals" role="region" aria-labelledby="visuals-heading" aria-hidden="true">
      <h1 id="visuals-heading" tabindex="-1">Visuals</h1>
      <div class="grid">
        <div class="visual">
          <img src="everything feels different in the dark.png" alt="Album artwork: everything feels different in the dark" width="800" height="600" loading="lazy">
        </div>
        <div class="visual">
          <img src="https://placehold.co/400x300" alt="Placeholder visual" loading="lazy" width="400" height="300">
        </div>
      </div>
      <button class="back-btn" type="button" onclick="goHome()">Back</button>
    </section>
  </main>

  <!-- Intro audio: replace 'boot.wav' with your small chiptune/boot sample -->
  <audio id="introAudio" preload="auto">
    <source src="boot.wav" type="audio/wav">
    <source src="boot.mp3" type="audio/mpeg">
  </audio>

  <!-- Ambient background audio -->
  <audio id="ambientAudio" loop preload="none">
    <source src="ambient.mp3" type="audio/mpeg">
  </audio>

  <!-- Hidden flicker sound effects -->
  <audio id="flickerSound1" preload="none"><source src="flicker1.mp3" type="audio/mpeg"></audio>
  <audio id="flickerSound2" preload="none"><source src="flicker2.mp3" type="audio/mpeg"></audio>

<script>
(() => {
  'use strict';

  /* ===============
     Cached elements & state
     =============== */
  const mainEl = document.querySelector('main');
  const introOverlay = document.getElementById('intro');
  const bootLinesEls = [
    document.getElementById('line1'),
    document.getElementById('line2'),
    document.getElementById('line3'),
    document.getElementById('line4')
  ];
  const bootLogo = document.getElementById('bootLogo');
  const introFlash = document.getElementById('introFlash');
  const soundEnableBtn = document.getElementById('soundEnableBtn');

  const introAudio = document.getElementById('introAudio');
  const ambientAudio = document.getElementById('ambientAudio');

  const logo = document.getElementById('logo');
  const menu = document.getElementById('menu');
  const stage = document.getElementById('stage');
  const popup = document.getElementById('popup');
  const sections = Array.from(document.querySelectorAll('.section'));
  const tellBtn = document.getElementById('tellBtn');
  const closePopup = document.getElementById('closePopup');
  const form = document.getElementById('tellMeForm');
  const formStatus = document.getElementById('formStatus');

  let lastFocusedElement = null;
  let modalKeyHandler = null;
  let flickerLoopTimer = null;
  let ambientFadeInterval = null;
  let introAudioAllowed = false;
  let activeTimeouts = new Set();
  let activeIntervals = new Set();

  /* ===============
     Helper utilities
     =============== */
  const safe = {
    setItem(key, value) {
      try { localStorage.setItem(key, value); } catch (e) { /* ignore */ }
    },
    getItem(key) {
      try { return localStorage.getItem(key); } catch (e) { return null; }
    }
  };

  function prefersReducedMotion() {
    return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  function setIntroPlayedFlag() {
    safe.setItem('synt_intro_played', '1');
  }
  function introWasPlayed() {
    return safe.getItem('synt_intro_played') === '1';
  }

  function wait(ms) {
    return new Promise(resolve => {
      const t = setTimeout(() => {
        activeTimeouts.delete(t);
        resolve();
      }, ms);
      activeTimeouts.add(t);
    });
  }

  function setTimeoutTracked(fn, ms) {
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.add(id);
    return id;
  }
  function clearAllTrackedTimeouts() {
    activeTimeouts.forEach(id => clearTimeout(id));
    activeTimeouts.clear();
  }

  function setIntervalTracked(fn, ms) {
    const id = setInterval(fn, ms);
    activeIntervals.add(id);
    return id;
  }
  function clearAllTrackedIntervals() {
    activeIntervals.forEach(id => clearInterval(id));
    activeIntervals.clear();
  }

  /* typed text (fast, with jitter). Slightly optimized: precompute length check */
  function typeText(el, text, charDelay = 18) {
    return new Promise(resolve => {
      el.textContent = '';
      let i = 0;
      function step() {
        if (i >= text.length) return resolve();
        el.textContent += text[i++];
        // jittered delay, keep small for snappy feel
        setTimeout(step, charDelay + Math.random() * 14);
      }
      step();
    });
  }

  /* gritty micro-glitch, returns promise so caller can await if desired */
  function grittyGlitch(el, repeats = 6, intensity = 1.6, speed = 60) {
    return new Promise(resolve => {
      let count = 0;
      const id = setInterval(() => {
        el.style.transform = `translate(${(Math.random() - 0.5) * intensity}px, ${(Math.random() - 0.5) * intensity}px) skew(${(Math.random() - 0.5) * 0.8}deg)`;
        el.style.opacity = 0.85 + Math.random() * 0.18;
        count++;
        if (count >= repeats) {
          clearInterval(id);
          el.style.transform = '';
          el.style.opacity = '';
          activeIntervals.delete(id);
          resolve();
        }
      }, speed);
      activeIntervals.add(id);
    });
  }

  /* flash overlay */
  function flashIntro(duration = 90) {
    if (introFlash) {
      introFlash.style.transition = `opacity ${duration}ms ease-out`;
      introFlash.style.opacity = '0.95';
      // tiny timeout to let transition apply then clear
      setTimeout(() => { introFlash.style.opacity = '0'; }, 30);
    }
  }

  /* hide intro overlay and tidy */
  function hideIntroOverlay() {
    introOverlay.style.transition = 'opacity 300ms ease';
    introOverlay.style.opacity = 0;
    // clear timers/intervals associated with intro
    clearAllTrackedIntervals();
    setTimeout(() => {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      // remove any event listeners specific to the intro if needed
    }, 360);
  }

  /* show main UI */
  function showMainUI() {
    mainEl.setAttribute('aria-hidden', 'false');
    stage.style.opacity = 1;
    // reveal menu after a short, consistent delay
    setTimeout(() => { menu.style.opacity = 1; }, 420);
    startFlickerLoop();
  }

  /* ===============
     Audio helpers
     =============== */

  async function tryPlayIntroAudio() {
    if (!introAudio) return false;
    try {
      introAudio.volume = 0.9;
      // unmute if necessary
      await introAudio.play();
      introAudioAllowed = true;
      soundEnableBtn.style.display = 'none';
      // listen for natural end so we can clear state
      introAudio.addEventListener('ended', () => { introAudioAllowed = false; }, { once: true });
      return true;
    } catch (err) {
      // autoplay is blocked; show enable button for user interaction
      introAudioAllowed = false;
      soundEnableBtn.style.display = 'inline-block';
      return false;
    }
  }

  soundEnableBtn.addEventListener('click', async (e) => {
    e.stopPropagation();
    try {
      await introAudio.play();
      introAudioAllowed = true;
      soundEnableBtn.style.display = 'none';
      // also attempt to start ambient
      ambientAudio.volume = 0;
      ambientAudio.play().catch(()=>{});
      fadeAudio(ambientAudio, 0.28, 1500);
    } catch (err) {
      console.warn('Sound enable failed:', err);
    }
  }, { passive: true });

  function fadeAudio(audio, targetVolume, duration) {
    clearInterval(ambientFadeInterval);
    const start = isFinite(audio.volume) ? audio.volume : 0;
    const steps = Math.max(1, Math.floor(duration / 50));
    const stepDelta = (targetVolume - start) / steps;
    let stepCount = 0;
    ambientFadeInterval = setInterval(() => {
      stepCount++;
      audio.volume = Math.min(Math.max(start + stepDelta * stepCount, 0), 1);
      if (stepCount >= steps) {
        clearInterval(ambientFadeInterval);
      }
    }, 50);
  }

  function startAmbientOnInteraction() {
    if (!ambientAudio) return;
    if (ambientAudio.paused) {
      ambientAudio.volume = 0;
      ambientAudio.play().catch(() => {});
      fadeAudio(ambientAudio, 0.28, 1800);
    }
    document.removeEventListener('pointerdown', startAmbientOnInteraction);
  }

  /* ===============
     Flicker behavior (post-intro)
     =============== */
  const flickerSounds = [
    document.getElementById('flickerSound1'),
    document.getElementById('flickerSound2')
  ];

  function playFlickerSound() {
    const sound = flickerSounds[Math.floor(Math.random() * flickerSounds.length)];
    if (sound) {
      try { sound.currentTime = 0; sound.play().catch(()=>{}); } catch(e) {}
    }
  }

  function flickerLoop() {
    // use requestAnimationFrame but throttle with a timeout to preserve randomness and performance
    if (Math.random() < 0.12) {
      logo.style.setProperty('--flicker-brightness', 3 + Math.random() * 2.2);
      logo.style.textShadow = "0 0 10px #fff,0 0 40px #fff,0 0 80px rgba(255,255,255,0.85)";
      playFlickerSound();
    } else {
      logo.style.setProperty('--flicker-brightness', 0.6 + Math.random() * 0.35);
      logo.style.textShadow = "0 0 4px #fff,0 0 12px rgba(255,255,255,0.5)";
    }
    // schedule next run
    const t = setTimeout(() => {
      activeTimeouts.delete(t);
      flickerLoop();
    }, 40 + Math.random() * 180);
    activeTimeouts.add(t);
  }

  function startFlickerLoop() {
    if (!flickerLoopTimer) {
      flickerLoopTimer = true; // flag that it started; actual timers are tracked
      flickerLoop();
    }
  }

  function stopFlickerLoop() {
    flickerLoopTimer = null;
    clearAllTrackedTimeouts();
  }

  /* ===============
     Section navigation / accessibility
     =============== */
  document.querySelectorAll('button.menu-box[data-section]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const sectionId = btn.dataset.section;
      const section = document.getElementById(sectionId);
      if (!section) return;
      stage.style.opacity = 0;
      sections.forEach(s => { s.style.display = 'none'; s.setAttribute('aria-hidden', 'true'); });
      // small delay for visual fade
      setTimeout(() => {
        section.style.display = 'flex';
        section.setAttribute('aria-hidden', 'false');
        const heading = section.querySelector('h1, h2');
        if (heading) heading.focus({preventScroll: true});
      }, 300);
    }, { passive: true });
  });

  /* ===============
     Focus trap utilities (modal)
     =============== */
  function getFocusableElements(container) {
    const selectors = [
      'a[href]','area[href]','input:not([disabled]):not([type="hidden"])','select:not([disabled])',
      'textarea:not([disabled])','button:not([disabled])','iframe','object','embed',
      '[contenteditable]','[tabindex]:not([tabindex="-1"])'
    ];
    return Array.from(container.querySelectorAll(selectors.join(','))).filter(el => {
      return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length;
    });
  }

  function trapFocus(container) {
    const focusable = getFocusableElements(container);
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];

    modalKeyHandler = function(e) {
      if (e.key === 'Tab') {
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };
    document.addEventListener('keydown', modalKeyHandler);
  }

  function releaseFocusTrap() {
    if (modalKeyHandler) {
      document.removeEventListener('keydown', modalKeyHandler);
      modalKeyHandler = null;
    }
  }

  /* ===============
     Modal popup handling
     =============== */
  tellBtn.addEventListener('click', () => {
    lastFocusedElement = document.activeElement;
    popup.style.display = 'flex';
    popup.setAttribute('aria-hidden', 'false');
    mainEl.setAttribute('aria-hidden', 'true');
    const firstControl = form.querySelector('input, textarea, button');
    if (firstControl) firstControl.focus();
    trapFocus(popup);
  });

  closePopup.addEventListener('click', closePopupFn);

  function closePopupFn() {
    popup.style.display = 'none';
    popup.setAttribute('aria-hidden', 'true');
    mainEl.setAttribute('aria-hidden', 'false');
    releaseFocusTrap();
    if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') lastFocusedElement.focus();
  }

  /* centralized Escape handling (intro, modal, sections) */
  function onGlobalKeydown(e) {
    if (e.key !== 'Escape') return;
    if (introOverlay && introOverlay.style.display !== 'none') {
      skipIntro();
      return;
    }
    if (popup.style.display === 'flex') {
      closePopupFn();
      return;
    }
    const anyVisible = sections.some(s => s.style.display === 'flex');
    if (anyVisible) goHome();
  }
  document.addEventListener('keydown', onGlobalKeydown);

  /* ===============
     Form submission (robust)
     =============== */
  let formSubmitting = false;
  async function submitFormRobust(evt) {
    evt.preventDefault();
    if (formSubmitting) return;
    formSubmitting = true;
    const submitBtn = form.querySelector('button[type="submit"]');
    if (submitBtn) submitBtn.disabled = true;

    formStatus.style.color = '';
    formStatus.textContent = "Sending...";

    const name = form.name.value.trim();
    const message = form.message.value.trim();

    if (!name || !message) {
      formStatus.style.color = 'var(--error)';
      formStatus.textContent = "Please fill out both fields.";
      formSubmitting = false;
      if (submitBtn) submitBtn.disabled = false;
      return;
    }

    const endpoint = form.action;
    const method = (form.method || 'POST').toUpperCase();

    // Try JSON POST first
    try {
      const res = await fetch(endpoint, {
        method,
        headers: {'Content-Type':'application/json','Accept':'application/json'},
        body: JSON.stringify({ name, message })
      });
      if (res.ok) {
        formStatus.style.color = 'var(--success)';
        formStatus.textContent = "Message sent ✓";
        form.reset();
        formSubmitting = false;
        if (submitBtn) submitBtn.disabled = false;
        return;
      }
      // Collect error info if not ok
      let info = res.statusText || `HTTP ${res.status}`;
      try { const json = await res.json(); info = json.error || json.message || info; } catch (e) {}
      console.warn('JSON POST rejected:', info);
    } catch (err) {
      console.warn('JSON POST failed:', err);
    }

    // Fallback: FormData POST
    try {
      const fd = new FormData();
      fd.append('name', name);
      fd.append('message', message);
      const res2 = await fetch(endpoint, { method, body: fd, headers: {'Accept':'application/json'} });
      if (res2.ok) {
        formStatus.style.color = 'var(--success)';
        formStatus.textContent = "Message sent ✓";
        form.reset();
        formSubmitting = false;
        if (submitBtn) submitBtn.disabled = false;
        return;
      }
      let info2 = res2.statusText || `HTTP ${res2.status}`;
      try { const json2 = await res2.json(); info2 = json2.error || json2.message || info2; } catch (e) {}
      console.warn('FormData POST rejected:', info2);
      formStatus.style.color = 'var(--error)';
      formStatus.textContent = `Server error: ${info2}`;
    } catch (err2) {
      console.warn('FormData POST failed:', err2);
    }

    // Final fallback: mailto link
    formStatus.style.color = 'var(--error)';
    formStatus.innerHTML = 'Could not send via the server. <a href="#" id="mailto-fallback">Send by email instead</a>';
    const mailtoLink = document.getElementById('mailto-fallback');
    if (mailtoLink) {
      const subject = encodeURIComponent('Message from synt website');
      const body = encodeURIComponent(`Name: ${name}\n\nMessage:\n${message}`);
      mailtoLink.href = `mailto:hello@example.com?subject=${subject}&body=${body}`;
      mailtoLink.addEventListener('click', () => { formStatus.textContent = 'Opening email client...'; }, { once: true });
    }

    formSubmitting = false;
    if (submitBtn) submitBtn.disabled = false;
  }
  form.addEventListener('submit', submitFormRobust);

  /* ===============
     goHome (restore stage)
     =============== */
  function goHome() {
    sections.forEach(s => { s.style.display = 'none'; s.setAttribute('aria-hidden', 'true'); });
    stage.style.opacity = 1;
    mainEl.setAttribute('aria-hidden', 'false');
    if (logo && typeof logo.focus === 'function') logo.focus();
  }
  // expose globally so onclick="goHome()" works
  window.goHome = goHome;

  /* ===============
     Intro sequence (play once; respects reduced motion)
     =============== */
  async function playIntroSequence() {
    if (prefersReducedMotion() || introWasPlayed()) {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
      setIntroPlayedFlag();
      return;
    }

    introOverlay.setAttribute('aria-hidden', 'false');
    introOverlay.style.display = 'flex';

    // try to start intro audio (will show enable button if blocked)
    tryPlayIntroAudio();

    const bootLines = [
      ">>> BIOS: SYNTH-8BIT v0.9.7",
      ">>> PERIPHERALS: OK  [GPU::CHIPGRID 0xFF]",
      ">>> LOADING: core.modules [████████▒▒] 80%",
      ">>> USER: WELCOME."
    ];

    for (let i = 0; i < bootLines.length; i++) {
      await typeText(bootLinesEls[i], bootLines[i], 12 + Math.random() * 8);
      await wait(140 + Math.max(0, 100 - i * 20));
      if (i === 1) {
        await grittyGlitch(bootLogo, 8, 2.6, 48);
        await wait(120);
      }
      if (i === 2) {
        await grittyGlitch(bootLinesEls[i], 10, 2.2, 42);
        await wait(110);
      }
    }

    for (let j = 0; j < 3; j++) {
      bootLogo.classList.toggle('flick');
      await wait(50 + Math.random() * 40);
    }

    await grittyGlitch(bootLogo, 10, 3.2, 36);
    flashIntro(90);

    // gracefully stop intro audio (fade then pause) if it was started
    if (introAudioAllowed && introAudio) {
      try {
        const startVol = isFinite(introAudio.volume) ? introAudio.volume : 1;
        const steps = 8;
        for (let s = 1; s <= steps; s++) {
          introAudio.volume = Math.max(0, startVol * (1 - s / steps));
          // small await to create fade
          // eslint-disable-next-line no-await-in-loop
          await wait(30);
        }
        try { introAudio.pause(); introAudio.currentTime = 0; } catch (err) {}
      } catch (err) {
        try { introAudio.pause(); introAudio.currentTime = 0; } catch (e) {}
      }
    }

    await wait(160);
    setIntroPlayedFlag();
    hideIntroOverlay();
    await wait(320);

    // if intro audio allowed, start ambient automatically; otherwise wait for interaction
    if (introAudioAllowed) {
      try {
        ambientAudio.volume = 0;
        ambientAudio.play().catch(()=>{});
        fadeAudio(ambientAudio, 0.28, 1600);
      } catch (e) {}
    } else {
      // listen for user to start ambient
      document.addEventListener('pointerdown', startAmbientOnInteraction, { once: true });
      soundEnableBtn.style.display = 'inline-block';
    }

    showMainUI();
  }

  /* allow skipping intro via click (but prevent accidental focus triggers) */
  function skipIntro() {
    setIntroPlayedFlag();
    hideIntroOverlay();
    try { introAudio.pause(); introAudio.currentTime = 0; } catch (e) {}
    // allow ambient to be started on next interaction
    document.addEventListener('pointerdown', startAmbientOnInteraction, { once: true });
    showMainUI();
  }

  // use pointerdown for immediate skipping (more responsive)
  introOverlay.addEventListener('pointerdown', (e) => {
    // skip if clicking outside interactive controls (soundEnableBtn handled separately)
    if (e.target === soundEnableBtn) return;
    skipIntro();
  }, { passive: true });

  /* ===============
     Init on DOM ready
     =============== */
  document.addEventListener('DOMContentLoaded', () => {
    // initial UI state
    menu.style.opacity = 0;
    mainEl.setAttribute('aria-hidden', 'true');

    if (prefersReducedMotion()) {
      // avoid animations for users who prefer reduced motion
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
      setIntroPlayedFlag();
      return;
    }

    if (!introWasPlayed()) {
      playIntroSequence().catch(err => {
        console.error('Intro sequence failed:', err);
        // fallback to ensure the site remains usable
        setIntroPlayedFlag();
        introOverlay.style.display = 'none';
        showMainUI();
      });
    } else {
      introOverlay.style.display = 'none';
      introOverlay.setAttribute('aria-hidden', 'true');
      showMainUI();
    }
  });

  /* ===============
     Clean up on page hide/unload
     =============== */
  window.addEventListener('pagehide', () => {
    clearAllTrackedIntervals();
    clearAllTrackedTimeouts();
    try { if (introAudio && !introAudio.paused) { introAudio.pause(); } } catch (_) {}
    try { if (ambientAudio && !ambientAudio.paused) { ambientAudio.pause(); } } catch (_) {}
  }, { passive: true });

})(); /* IIFE end */
</script>

<!-- ==========================
     SYNTH OVERLAY (merged, scoped)
     - Only this block was added to your file.
     - No other styles or markup were changed.
     - Open it with window.openSynthOverlay(), the menu button, or press Alt+M.
   ========================== -->
<style>
/* Scoped synth styles only */
#synthOverlay { position: fixed; inset: 6vh 8vw; z-index: 1200; display: none; background: linear-gradient(180deg,#050505,#0b0b0b); border-radius: 8px; padding: 10px; box-shadow: 0 30px 80px rgba(0,0,0,0.85); color:#fff; font-family: monospace; border: 3px solid rgba(255,255,255,0.04); overflow:auto; max-height:88vh; }
#synthOverlay .synth-head { display:flex;align-items:center;justify-content:space-between;gap:12px;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.03) }
#synthOverlay .synth-brand { font-weight:900; letter-spacing: .18em; text-transform:uppercase; font-size:.92rem }
#synthOverlay .synth-leds { display:flex; gap:8px; align-items:center }
#synthOverlay .synth-led { width:10px; height:10px; border-radius:50%; background:#222; box-shadow: 0 0 8px rgba(0,0,0,0.6) inset; border:1px solid rgba(255,255,255,0.04); opacity:.35 }
#synthOverlay .synth-led.red { background: linear-gradient(180deg,#400,#ff5c5c); box-shadow: 0 0 8px rgba(255,64,64,0.22) }
#synthOverlay .synth-led.amber { background: linear-gradient(180deg,#744400,#ffb84d); box-shadow: 0 0 8px rgba(255,160,64,0.18) }
#synthOverlay .synth-led.green { background: linear-gradient(180deg,#003300,#5eff8a); box-shadow: 0 0 8px rgba(64,255,144,0.18) }

#synthOverlay .synth-body { display:grid; grid-template-columns: 360px 1fr 320px; gap:12px; padding:12px; align-items:start }
@media (max-width:1100px){ #synthOverlay .synth-body { grid-template-columns: 1fr; } #synthOverlay { inset: 6vh 4vw; } }
#synthOverlay .synth-controls { background: linear-gradient(180deg,#0a0a0a,#0f0f0f); padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,0.03) }
#synthOverlay .ctrl { display:flex; align-items:center; gap:8px; margin-bottom:8px }
#synthOverlay .ctrl label { min-width:84px; font-size:.88rem; color:#ddd }
#synthOverlay .ctrl input[type=range] { flex:1; appearance:none; height:8px; background:linear-gradient(90deg,#1c1c1c,#2b2b2b); border-radius:8px; border:1px solid rgba(255,255,255,0.02) }
#synthOverlay .ctrl input[type=range]::-webkit-slider-thumb{ appearance:none; width:14px;height:14px;background:#fff;border-radius:50%;border:2px solid #111 }
#synthOverlay .ctrl select { background:#0b0b0b;color:#fff;border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:6px }

#synthOverlay .synth-box { background: linear-gradient(180deg,#060606,#0b0b0b); padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); box-shadow: inset 0 -8px 18px rgba(0,0,0,0.6) }
#synthOverlay .synth-box-top { display:flex; align-items:center; gap:12px; justify-content:space-between; margin-bottom:10px }
#synthOverlay .oled { width:320px; height:56px; background:#00110a; border-radius:6px; border:2px solid rgba(255,255,255,0.03); overflow:hidden; box-shadow: inset 0 6px 14px rgba(0,0,0,0.6) }
#synthOverlay .oled canvas { width:100%; height:100%; display:block; image-rendering: pixelated }
#synthOverlay .keys { display:block; position:relative; user-select:none; padding:6px 10px; border-radius:6px; background: linear-gradient(180deg,#070707,#0b0b0b); border:1px solid rgba(255,255,255,0.02); box-shadow: inset 0 -8px 18px rgba(0,0,0,0.5); flex-wrap:wrap }
#synthOverlay .keys-row { display:flex; gap:6px; align-items:flex-end; padding-bottom:6px; flex-wrap:wrap }
#synthOverlay .key { width:54px; height:170px; background:linear-gradient(180deg,#fff,#efefef); border-radius:6px; border:2px solid #111; box-shadow: 0 14px 36px rgba(0,0,0,0.6); display:flex; align-items:flex-end; justify-content:center; font-weight:800; color:#111; font-size:12px; padding-bottom:8px; cursor:pointer; transition: transform .06s, box-shadow .06s }
#synthOverlay .key.down { transform: translateY(4px); box-shadow: 0 8px 18px rgba(0,0,0,0.6); background: linear-gradient(180deg,#ffe,#ddd) }
#synthOverlay .key.black { width:40px; height:110px; margin-left:-20px; margin-right:-20px; background:linear-gradient(180deg,#0b0b0b,#141414); color:#fff; z-index:2; border-radius:4px; box-shadow: 0 18px 38px rgba(0,0,0,0.8) }
#synthOverlay .analyzer { width:100%; height:140px; background: linear-gradient(180deg,#020202,#050505); border-radius:6px; border:1px solid rgba(255,255,255,0.03); overflow:hidden }

#synthOverlay .synth-effects { background: linear-gradient(180deg,#0a0a0a,#0e0e0e); padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); }
#synthOverlay .btn { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:transparent;color:#fff; cursor:pointer; margin-right:6px }
#synthOverlay .footer-row { display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:10px }
@media (max-width:700px){
  #synthOverlay .key { width:40px; height:130px; font-size:11px }
  #synthOverlay .key.black { width:26px; height:84px; margin-left:-13px; margin-right:-13px }
}
</style>

<!-- Synth overlay HTML (scoped) -->
<div id="synthOverlay" role="dialog" aria-modal="true" aria-hidden="true" aria-label="Gritty digital synthesizer (box)">
  <div class="synth-head">
    <div class="synth-brand">Noise Station • MKII</div>
    <div class="synth-leds" aria-hidden="true">
      <span class="synth-led red" id="s-led-red"></span>
      <span class="synth-led amber" id="s-led-amber"></span>
      <span class="synth-led green" id="s-led-green"></span>
    </div>
  </div>

  <div class="synth-body">
    <!-- Left controls -->
    <div class="synth-controls" aria-hidden="false">
      <div class="ctrl"><label for="s-osc">Osc</label><select id="s-osc"><option value="sawtooth">sawtooth</option><option value="square">square</option><option value="triangle">triangle</option><option value="sine">sine</option><option value="pulse">pulse</option></select></div>
      <div class="ctrl"><label for="s-master">Master</label><input id="s-master" type="range" min="0" max="1" step="0.01" value="0.45"></div>
      <div class="ctrl"><label for="s-cut">Filter</label><input id="s-cut" type="range" min="40" max="12000" step="1" value="2000"></div>
      <div class="ctrl"><label for="s-q">Q</label><input id="s-q" type="range" min="0.1" max="20" step="0.1" value="1.8"></div>
      <div class="ctrl"><label for="s-dist">Dist</label><input id="s-dist" type="range" min="0" max="80" step="1" value="18"></div>
      <div class="ctrl"><label for="s-bits">Bits</label><input id="s-bits" type="range" min="2" max="16" step="1" value="8"></div>
      <div class="ctrl"><label for="s-sr">Samp</label><input id="s-sr" type="range" min="1" max="20" step="1" value="6"></div>
      <div class="ctrl"><label for="s-noise">Noise</label><input id="s-noise" type="range" min="0" max="1" step="0.01" value="0.08"></div>
      <div style="height:6px"></div>
      <div class="ctrl"><label for="s-atk">A</label><input id="s-atk" type="range" min="0" max="1" step="0.01" value="0.002"></div>
      <div class="ctrl"><label for="s-dec">D</label><input id="s-dec" type="range" min="0" max="2" step="0.01" value="0.12"></div>
      <div class="ctrl"><label for="s-sus">S</label><input id="s-sus" type="range" min="0" max="1" step="0.01" value="0.46"></div>
      <div class="ctrl"><label for="s-rel">R</label><input id="s-rel" type="range" min="0" max="3" step="0.01" value="0.4"></div>
    </div>

    <!-- Center hardware box -->
    <div class="synth-box" role="region" aria-label="synth hardware">
      <div class="synth-box-top">
        <div style="display:flex;align-items:center;gap:8px">
          <div style="font-weight:700">NOISE-CORE</div>
          <div style="opacity:.8;font-size:.82rem">Gritty digital</div>
        </div>
        <div class="oled" aria-hidden="true"><canvas id="s-oled" width="320" height="56"></canvas><div class="scan"></div></div>
      </div>

      <!-- Keys -->
      <div class="keys" id="s-keys">
        <div class="keys-row" id="s-white-keys"></div>
        <div style="height:8px"></div>
      </div>

      <!-- Analyzer -->
      <canvas id="s-analyzer" class="analyzer" width="900" height="140" aria-hidden="true"></canvas>

      <div class="footer-row" style="margin-top:8px">
        <div>
          <button id="s-play" class="btn">Play demo</button>
          <button id="s-stop" class="btn">Stop</button>
        </div>
        <div>
          <button id="s-random" class="btn">Randomize</button>
          <button id="s-close" class="btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Right effects -->
    <div class="synth-effects">
      <div style="font-weight:700;margin-bottom:8px">Effects</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="s-grit" class="btn">Grit</button>
        <button id="s-lfo" class="btn">LFO→F</button>
        <button id="s-delay" class="btn">Delay</button>
        <button id="s-rev" class="btn">Reverb</button>
      </div>
      <div style="margin-top:12px;font-size:.86rem;opacity:.85">Tip: click keys or press keyboard (z..m / q..u).</div>
    </div>
  </div>
</div>

<script>
/* Synth overlay script (scoped, IIFE) */
/* Exposes window.openSynthOverlay() and responds to Alt+M to toggle. */
(function () {
  'use strict';

  // DOM refs (synth)
  const overlay = document.getElementById('synthOverlay');
  const ledRed = document.getElementById('s-led-red');
  const ledAmber = document.getElementById('s-led-amber');
  const ledGreen = document.getElementById('s-led-green');

  const oscSel = document.getElementById('s-osc');
  const master = document.getElementById('s-master');
  const cut = document.getElementById('s-cut');
  const q = document.getElementById('s-q');
  const dist = document.getElementById('s-dist');
  const bits = document.getElementById('s-bits');
  const sr = document.getElementById('s-sr');
  const noiseMix = document.getElementById('s-noise');
  const atk = document.getElementById('s-atk'), dcy = document.getElementById('s-dec'), sus = document.getElementById('s-sus'), rel = document.getElementById('s-rel');

  const oledCanvas = document.getElementById('s-oled'), oledCtx = oledCanvas.getContext('2d');
  const analyzerCanvas = document.getElementById('s-analyzer'), analyzerCtx = analyzerCanvas.getContext('2d');
  const whiteKeysRow = document.getElementById('s-white-keys');

  const btnPlay = document.getElementById('s-play'), btnStop = document.getElementById('s-stop'), btnRandom = document.getElementById('s-random'), btnClose = document.getElementById('s-close');
  const btnGrit = document.getElementById('s-grit'), btnLFO = document.getElementById('s-lfo'), btnDelay = document.getElementById('s-delay'), btnRev = document.getElementById('s-rev');

  // Optional: wire any existing button with id="synthBtn" if present
  const openButton = document.getElementById('synthBtn');

  // Audio nodes & state
  let audioCtx = null;
  let masterGain = null, filter = null, shaper = null, bitCrusher = null, delayNode = null, delayFB = null, convolver = null, analyser = null, analyserData = null;
  let lfoOsc = null, lfoGain = null;
  let noiseBuf = null;
  let activeVoices = new Set();

  // Animation control
  let rafId = null;
  const TARGET_FPS = 40;
  const FRAME_INTERVAL = 1000 / TARGET_FPS;
  let lastFrame = 0;

  // Notes array (C3 .. B4)
  const NOTES = [];
  for (let m = 48; m <= 71; m++) {
    const freq = 440 * Math.pow(2, (m - 69) / 12);
    const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    NOTES.push({ midi: m, freq, name: names[m % 12] + (Math.floor(m / 12) - 1) });
  }
  const KEYMAP = ['z','s','x','d','c','v','g','b','h','n','j','m','q','2','w','3','e','r','5','t','6','y','7','u'];

  const ANALYSER_FFT = 512;

  // ensure audio context and nodes (create once)
  function ensureAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audioCtx = new AC();

    masterGain = audioCtx.createGain();
    masterGain.gain.value = parseFloat(master.value || 0.45);
    masterGain.connect(audioCtx.destination);

    filter = audioCtx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = parseFloat(cut.value || 2000);
    filter.Q.value = parseFloat(q.value || 1.8);

    shaper = audioCtx.createWaveShaper();
    shaper.curve = makeDistortion(parseFloat(dist.value || 18));
    shaper.oversample = '4x';

    createBitCrusher();

    delayNode = audioCtx.createDelay(5.0);
    delayNode.delayTime.value = 0.28;
    delayFB = audioCtx.createGain();
    delayFB.gain.value = 0.32;
    delayNode.connect(delayFB); delayFB.connect(delayNode);

    convolver = audioCtx.createConvolver();
    convolver.buffer = createReverbImpulse(2.0, 2.4);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = ANALYSER_FFT;
    analyserData = new Uint8Array(analyser.frequencyBinCount);

    // routing
    filter.connect(analyser);
    analyser.connect(masterGain);
    delayNode.connect(analyser);
    convolver.connect(analyser);

    // LFO
    lfoOsc = audioCtx.createOscillator();
    lfoOsc.type = 'sine';
    lfoOsc.frequency.value = 3.2;
    lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 0;
    lfoOsc.connect(lfoGain);
    try { lfoOsc.start(); } catch (e) {}
  }

  function createBitCrusher() {
    if (!audioCtx) return;
    if (bitCrusher) try { bitCrusher.disconnect(); } catch(e) {}
    try {
      const bufferSize = 2048;
      const node = audioCtx.createScriptProcessor(bufferSize, 1, 1);
      node.onaudioprocess = function(e) {
        const input = e.inputBuffer.getChannelData(0);
        const output = e.outputBuffer.getChannelData(0);
        const bitDepth = Math.max(2, Math.min(16, parseInt(bits.value || 8,10)));
        const step = Math.pow(0.5, bitDepth);
        const reduction = Math.max(1, parseInt(sr.value || 6,10));
        let ph = 0; let last = 0;
        for (let i=0;i<input.length;i++){
          ph++;
          if (ph >= reduction) { ph = 0; last = step * Math.floor(input[i] / step + 0.5); }
          output[i] = last;
        }
      };
      bitCrusher = node;
    } catch (err) {
      console.warn('bitcrusher failed', err);
      bitCrusher = null;
    }
  }

  function makeDistortion(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i=0;i<samples;i++){
      const x = (i*2)/samples - 1;
      curve[i] = ((3+k)*x*20*deg) / (Math.PI + k*Math.abs(x));
    }
    return curve;
  }

  function createReverbImpulse(duration = 2.0, decay = 2.0) {
    if (!audioCtx) return null;
    const rate = audioCtx.sampleRate;
    const len = rate * duration;
    const buff = audioCtx.createBuffer(2, len, rate);
    for (let ch=0; ch<2; ch++){
      const data = buff.getChannelData(ch);
      for (let i=0;i<len;i++) data[i] = (Math.random()*2 -1) * Math.pow(1 - i/len, decay);
    }
    return buff;
  }

  function ensureNoiseBuffer() {
    if (noiseBuf || !audioCtx) return;
    const len = audioCtx.sampleRate * 2;
    noiseBuf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const d = noiseBuf.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = Math.random()*2 - 1;
  }

  // voice play
  function playVoice(freq) {
    if (!audioCtx) ensureAudio();
    if (!audioCtx) return null;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const type = oscSel.value;
    osc.type = (type === 'pulse') ? 'square' : type;
    osc.frequency.value = freq;

    const localShaper = shaper;
    localShaper.curve = makeDistortion(parseFloat(dist.value || 0));
    osc.connect(localShaper);

    if (bitCrusher) {
      localShaper.connect(bitCrusher);
      bitCrusher.connect(filter);
    } else {
      localShaper.connect(filter);
    }

    ensureNoiseBuffer();
    let noiseSrc = null;
    if (noiseBuf && parseFloat(noiseMix.value) > 0.0001) {
      noiseSrc = audioCtx.createBufferSource();
      noiseSrc.buffer = noiseBuf;
      const ng = audioCtx.createGain();
      ng.gain.value = parseFloat(noiseMix.value || 0.08);
      noiseSrc.loop = true;
      noiseSrc.connect(ng);
      ng.connect(filter);
      noiseSrc.start();
    }

    const outGain = audioCtx.createGain(); outGain.gain.value = 0;
    filter.connect(outGain);
    outGain.connect(analyser);
    if (delayOn) outGain.connect(delayNode);
    if (revOn) outGain.connect(convolver);

    // ADSR
    const attack = parseFloat(atk.value) || 0.01;
    const decay = parseFloat(dcy.value) || 0.1;
    const sustain = parseFloat(sus.value) || 0.6;
    const release = parseFloat(rel.value) || 0.5;

    outGain.gain.cancelScheduledValues(now);
    outGain.gain.setValueAtTime(0.0001, now);
    outGain.gain.linearRampToValueAtTime(1.0, now + attack);
    outGain.gain.exponentialRampToValueAtTime(Math.max(0.001, sustain), now + attack + decay);

    try { osc.start(); } catch(e) {}

    const voice = {
      osc, outGain, noiseSrc,
      stop: (when = 0) => {
        const t = audioCtx.currentTime + when;
        outGain.gain.cancelScheduledValues(t);
        outGain.gain.setValueAtTime(outGain.gain.value, t);
        outGain.gain.exponentialRampToValueAtTime(0.0001, t + release);
        setTimeout(() => {
          try { osc.stop(); } catch(e) {}
          if (noiseSrc) try { noiseSrc.stop(); } catch(e) {}
          try { osc.disconnect(); } catch(e) {}
          try { outGain.disconnect(); } catch(e) {}
        }, (release + 0.05) * 1000 + 30);
      }
    };
    activeVoices.add(voice);
    return voice;
  }

  function stopAllVoices() {
    activeVoices.forEach(v => { try { v.stop(0); } catch(e){} });
    activeVoices.clear();
  }

  // Build key UI
  function buildKeys() {
    if (whiteKeysRow.children.length) return;
    NOTES.forEach((n, idx) => {
      const el = document.createElement('div');
      const isSharp = n.name.includes('#');
      el.className = isSharp ? 'key black' : 'key';
      el.dataset.index = idx;
      el.dataset.freq = n.freq;
      el.innerHTML = `<div style="padding-bottom:8px;font-size:12px;font-weight:800">${n.name}</div>`;
      // events
      el.addEventListener('pointerdown', ev => { ev.preventDefault(); keyDown(el); }, { passive:false });
      el.addEventListener('pointerup', ev => { ev.preventDefault(); keyUp(el); }, { passive:false });
      el.addEventListener('pointerleave', ev => { if (ev.buttons === 1) keyUp(el); }, { passive:true });
      whiteKeysRow.appendChild(el);
    });
  }

  // live map
  const live = new Map();
  function keyDown(keyEl) {
    const idx = parseInt(keyEl.dataset.index,10);
    const note = NOTES[idx];
    if (!note) return;
    if (live.has(keyEl)) return;
    keyEl.classList.add('down');
    const voice = playVoice(note.freq);
    live.set(keyEl, voice);
    startAnimations();
  }
  function keyUp(keyEl) {
    const v = live.get(keyEl);
    if (v) { try { v.stop(0); } catch(e){} live.delete(keyEl); }
    keyEl.classList.remove('down');
    if (live.size === 0) {
      setTimeout(() => { if (live.size === 0 && activeVoices.size === 0) stopAnimations(); }, 250);
    }
  }

  // demo arpeggio
  let demoHandle = null;
  function startDemo() {
    stopAllVoices();
    if (!audioCtx) ensureAudio();
    const seq = [0,3,7,10,7,3];
    let i = 0;
    demoHandle = setInterval(() => {
      const midiBase = 60;
      const midi = midiBase + seq[i % seq.length];
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      const v = playVoice(freq);
      setTimeout(()=>{ try { v.stop(0); } catch(e){} }, 300);
      i++;
    }, 220);
    startAnimations();
  }
  function stopDemo() {
    if (demoHandle) { clearInterval(demoHandle); demoHandle = null; }
    stopAllVoices();
  }

  // effects toggles
  let gritOn = true, lfoOn = false, delayOn = false, revOn = false;
  btnGrit.addEventListener('click', () => {
    gritOn = !gritOn;
    btnGrit.textContent = gritOn ? 'Grit (on)' : 'Grit';
    if (gritOn) dist.value = Math.max(12, dist.value), bits.value = Math.max(6, bits.value);
    else { dist.value = 0; bits.value = 16; }
    if (shaper) shaper.curve = makeDistortion(parseFloat(dist.value));
  });
  btnLFO.addEventListener('click', () => {
    lfoOn = !lfoOn;
    btnLFO.textContent = lfoOn ? 'LFO→F (on)' : 'LFO→F';
    if (!audioCtx) ensureAudio();
    if (lfoOn) {
      lfoGain.gain.setValueAtTime(600, audioCtx.currentTime);
      try { lfoGain.connect(filter.frequency); } catch(e) {}
    } else {
      try { lfoGain.disconnect(filter.frequency); } catch(e) {}
    }
  });
  btnDelay.addEventListener('click', () => { delayOn = !delayOn; btnDelay.textContent = delayOn ? 'Delay (on)' : 'Delay'; });
  btnRev.addEventListener('click', () => { revOn = !revOn; btnRev.textContent = revOn ? 'Reverb (on)' : 'Reverb'; });

  // controls wiring
  master.addEventListener('input', () => { if (masterGain) masterGain.gain.setValueAtTime(parseFloat(master.value), audioCtx.currentTime); });
  cut.addEventListener('input', () => { if (filter) filter.frequency.setValueAtTime(parseFloat(cut.value), audioCtx.currentTime); });
  q.addEventListener('input', () => { if (filter) filter.Q.setValueAtTime(parseFloat(q.value), audioCtx.currentTime); });
  dist.addEventListener('input', () => { if (shaper) shaper.curve = makeDistortion(parseFloat(dist.value)); });
  bits.addEventListener('input', () => { if (audioCtx) { try { if (bitCrusher) bitCrusher.disconnect(); } catch(e){} createBitCrusher(); }});
  sr.addEventListener('input', () => { if (audioCtx) { try { if (bitCrusher) bitCrusher.disconnect(); } catch(e){} createBitCrusher(); }});

  // synth UI buttons
  btnPlay.addEventListener('click', startDemo);
  btnStop.addEventListener('click', stopDemo);
  btnRandom.addEventListener('click', () => {
    oscSel.value = ['sawtooth','square','triangle','sine','pulse'][Math.floor(Math.random()*5)];
    master.value = (0.2 + Math.random()*0.7).toFixed(2);
    cut.value = Math.round(200 + Math.random()*8000);
    q.value = (0.5 + Math.random()*8).toFixed(2);
    dist.value = Math.round(Math.random()*70);
    bits.value = 2 + Math.floor(Math.random()*14);
    sr.value = 1 + Math.floor(Math.random()*19);
    noiseMix.value = (Math.random()*0.35).toFixed(2);
    atk.value = (Math.random()*0.06).toFixed(3);
    dcy.value = (Math.random()*0.6).toFixed(2);
    sus.value = (0.2 + Math.random()*0.8).toFixed(2);
    rel.value = (0.05 + Math.random()*1.6).toFixed(2);
    if (shaper) shaper.curve = makeDistortion(parseFloat(dist.value));
    createBitCrusher();
  });
  document.getElementById('s-close').addEventListener('click', () => {
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');
    stopDemo(); stopAllVoices(); stopAnimations();
    if (openButton) openButton.setAttribute('aria-expanded','false');
  });

  // keyboard mapping
  document.addEventListener('keydown', (ev) => {
    if (overlay.style.display !== 'block') return;
    const k = ev.key.toLowerCase();
    const idx = KEYMAP.indexOf(k);
    if (idx >= 0 && NOTES[idx]) {
      const keyEl = document.querySelector(`#s-white-keys .key[data-index="${idx}"]`);
      if (keyEl && !keyEl.classList.contains('down')) keyDown(keyEl);
    }
  });
  document.addEventListener('keyup', (ev) => {
    if (overlay.style.display !== 'block') return;
    const k = ev.key.toLowerCase();
    const idx = KEYMAP.indexOf(k);
    if (idx >= 0 && NOTES[idx]) {
      const keyEl = document.querySelector(`#s-white-keys .key[data-index="${idx}"]`);
      if (keyEl) keyUp(keyEl);
    }
  });

  // animations (one RAF throttled)
  let ledTick = 0;
  function startAnimations() {
    if (rafId) return;
    lastFrame = performance.now();
    function loop(now) {
      const dt = now - lastFrame;
      if (dt >= FRAME_INTERVAL) {
        drawOLED(now);
        drawAnalyzer();
        ledTick = (ledTick + 1) % 60;
        ledGreen.style.opacity = (ledTick % 47 === 0) ? '1' : '0.35';
        ledAmber.style.opacity = (ledTick % 13 === 0) ? '1' : '0.35';
        ledRed.style.opacity = activeVoices.size ? '1' : (ledTick % 19 === 0 ? '0.85' : '0.35');
        lastFrame = now;
      }
      rafId = requestAnimationFrame(loop);
    }
    rafId = requestAnimationFrame(loop);
  }
  function stopAnimations() {
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    if (oledCtx) { oledCtx.clearRect(0,0,oledCanvas.width, oledCanvas.height); }
    if (analyzerCtx) { analyzerCtx.clearRect(0,0,analyzerCanvas.width, analyzerCanvas.height); }
  }

  function drawOLED(now) {
    if (!oledCtx) return;
    const w = oledCanvas.width, h = oledCanvas.height;
    oledCtx.fillStyle = '#00140b';
    oledCtx.fillRect(0,0,w,h);
    const t = now * 0.002;
    oledCtx.strokeStyle = '#8bffb6';
    oledCtx.lineWidth = 1.2;
    oledCtx.beginPath();
    for (let x=0;x<w;x+=2) {
      const y = h/2 + Math.sin((x*0.06) + t) * (h/3) * 0.35;
      if (x===0) oledCtx.moveTo(x,y); else oledCtx.lineTo(x,y);
    }
    oledCtx.stroke();
    oledCtx.fillStyle = '#2fe3a0';
    oledCtx.font = '11px monospace';
    const osc = (oscSel.value || 'saw').substring(0,6);
    oledCtx.fillText(`${osc}  F:${Math.round(cut.value)}`, 8, 14);
    oledCtx.fillText(`D:${Math.round(dist.value)} B:${bits.value}`, 8, 30);
    oledCtx.fillStyle = 'rgba(255,255,255,0.02)';
    for (let y=0;y<h;y+=2) oledCtx.fillRect(0,y,w,1);
  }

  function drawAnalyzer() {
    if (!analyser || !analyserData) return;
    analyser.getByteTimeDomainData(analyserData);
    const w = analyzerCanvas.width, h = analyzerCanvas.height;
    analyzerCtx.fillStyle = '#050505';
    analyzerCtx.fillRect(0,0,w,h);
    analyzerCtx.lineWidth = 2;
    analyzerCtx.strokeStyle = '#fff';
    analyzerCtx.beginPath();
    const slice = w / analyserData.length;
    for (let i=0;i<analyserData.length;i++){
      const v = analyserData[i] / 128.0;
      const y = v * h / 2;
      const x = i * slice;
      if (i===0) analyzerCtx.moveTo(x,y); else analyzerCtx.lineTo(x,y);
    }
    analyzerCtx.stroke();
    analyzerCtx.globalCompositeOperation = 'lighter';
    analyzerCtx.fillStyle = 'rgba(0,255,160,0.02)';
    analyzerCtx.fillRect(0,0,w,h);
    analyzerCtx.globalCompositeOperation = 'source-over';
  }

  // open/close helpers
  function openOverlay() {
    ensureAudio();
    overlay.style.display = 'block';
    overlay.setAttribute('aria-hidden','false');
    buildKeys();
    startAnimations();
    if (openButton) openButton.setAttribute('aria-expanded','true');
  }
  function closeOverlay() {
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden','true');
    stopDemo(); stopAllVoices(); stopAnimations();
    if (openButton) openButton.setAttribute('aria-expanded','false');
  }

  // Expose for console or other scripts
  window.openSynthOverlay = openOverlay;
  window.closeSynthOverlay = closeOverlay;

  // wire optional button if present
  if (openButton) {
    openButton.addEventListener('click', () => {
      if (overlay.style.display === 'block') closeOverlay(); else openOverlay();
    });
    // ensure initial aria attributes
    openButton.setAttribute('aria-controls', 'synthOverlay');
    openButton.setAttribute('aria-expanded', overlay.style.display === 'block' ? 'true' : 'false');
  }

  // Alt+M quick toggle (non-visual)
  document.addEventListener('keydown', (e) => {
    if (e.altKey && e.key.toLowerCase() === 'm') {
      e.preventDefault();
      if (overlay.style.display === 'block') closeOverlay(); else openOverlay();
    }
  });

  // ensure keys built
  buildKeys();

  // cleanup on pagehide
  window.addEventListener('pagehide', () => {
    stopAllVoices(); stopAnimations();
    try { if (audioCtx) audioCtx.close(); } catch(e) {}
    audioCtx = null;
  }, { passive: true });

  // expose internals cheaply for debugging
  window._synth = { ensureAudio, playVoice, stopAllVoices, openOverlay, closeOverlay };

})();
</script>

<!-- GUESTBOOK WIDGET (Dark, lined, with Copy button) START -->
<style>
  :root {
    --gb-bg: var(--card-bg);
    --gb-text: var(--fg);
    --gb-accent: var(--accent);
    --gb-muted: rgba(255,255,255,0.36);
    --gb-radius: 8px;
    --gb-shadow: 0 18px 60px rgba(0,0,0,0.7);
    --gb-font: var(--font-family);
    --gb-line: rgba(255,255,255,0.04);
  }

  .gb-trigger {
    position: fixed;
    right: 18px;
    bottom: 18px;
    width: 36px;
    height: 36px;
    border-radius: 8px;
    display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,0.02);
    color: var(--gb-text);
    cursor:pointer;
    z-index: 1500;
    opacity: 0.22;
    transition: opacity .18s ease, transform .12s ease;
    border: 1px solid rgba(255,255,255,0.03);
    backdrop-filter: blur(3px);
    font-family: var(--gb-font);
  }
  .gb-trigger:hover { opacity:0.95; transform: translateY(-2px); }

  .gb-backdrop {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.6);
    display: none; align-items:center; justify-content:center;
    z-index:1499;
  }
  .gb-backdrop.active { display:flex; }

  .gb-modal {
    width: min(520px, calc(100% - 40px));
    max-height: calc(100vh - 80px);
    border-radius: var(--gb-radius);
    background: var(--gb-bg);
    color: var(--gb-text);
    box-shadow: var(--gb-shadow);
    overflow:hidden;
    display:flex; flex-direction:column;
    font-family: var(--gb-font);
    border: 1px solid rgba(255,255,255,0.04);
  }

  .gb-header {
    padding:12px 14px; display:flex; align-items:center; justify-content:space-between;
    border-bottom: 1px solid rgba(255,255,255,0.03);
    font-weight:700; font-size:14px;
  }
  .gb-sub { color: var(--gb-muted); font-size:12px; font-weight:400; margin-left:8px; }

  .gb-close, .gb-admin-toggle {
    background:transparent;border:0;color:var(--gb-muted);cursor:pointer;padding:8px;border-radius:6px;
  }
  .gb-close:hover, .gb-admin-toggle:hover { color:var(--gb-text); background: rgba(255,255,255,0.02); }

  .gb-body { padding:12px; overflow:auto; display:flex; gap:12px; flex-direction:column; }

  .gb-form { display:grid; gap:8px; }
  .gb-form input[type="text"], .gb-form textarea {
    width:100%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04);
    font-size:13px; color:var(--gb-text); background: rgba(255,255,255,0.01); resize:vertical; font-family: var(--gb-font);
  }
  .gb-actions { display:flex; gap:8px; align-items:center; }
  .gb-btn { background: var(--gb-accent); color: var(--gb-text); border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }
  .gb-btn.ghost { background:transparent; color:var(--gb-text); border:1px solid rgba(255,255,255,0.04); }

  .gb-drawer { display:none; border-radius:8px; border:1px dashed rgba(255,255,255,0.03); padding:8px; background: rgba(255,255,255,0.01); }
  .gb-drawer.active { display:block; }

  .gb-canvas-wrap { display:flex; gap:8px; align-items:flex-start; }
  .gb-canvas { border:1px solid rgba(255,255,255,0.03); border-radius:6px; background:#fff; touch-action:none; }
  .gb-tools { display:flex; gap:6px; flex-direction:column; align-items:center; }
  .gb-tool { padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:var(--gb-text); cursor:pointer; font-size:12px; }

  .gb-messages { display:flex; gap:10px; flex-direction:column; }
  .gb-msg { border-radius:8px; padding:10px; background:transparent; display:flex; gap:10px; align-items:flex-start; border-bottom:1px solid var(--gb-line); }
  .gb-msg .meta { font-size:12px; color:var(--gb-muted); margin-bottom:6px; display:flex; justify-content:space-between; gap:8px; align-items:center; width:100%; }
  .gb-msg .content { white-space:pre-wrap; font-size:14px; color:var(--gb-text); font-family:var(--gb-font); }
  .gb-msg img { max-width:160px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); }
  .gb-msg .controls { display:flex; gap:6px; align-items:center; }
  .gb-msg button.copy { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--gb-text); padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
  .gb-msg button.del { background:transparent; border:0; color:#ff7a7a; cursor:pointer; padding:6px; font-size:12px; border-radius:6px; }

  .gb-footer { padding:10px; border-top:1px solid rgba(255,255,255,0.03); display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .gb-muted { color:var(--gb-muted); font-size:12px; }

  @media (max-width:520px){
    .gb-modal { width: calc(100% - 24px); }
    .gb-canvas { width: 220px; height:150px; }
    .gb-msg img { max-width:120px; }
  }
</style>

<div class="gb-trigger" id="gb-trigger" title="Open guestbook" aria-label="Open guestbook" role="button" tabindex="0">
  <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M3 5.5A2.5 2.5 0 015.5 3h11A2.5 2.5 0 0119 5.5V19a1 1 0 01-1 1H6a1 1 0 01-1-1V5.5z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 8h8M8 12h8" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
</div>

<div class="gb-backdrop" id="gb-backdrop" aria-hidden="true">
  <div class="gb-modal" role="dialog" aria-modal="true" aria-labelledby="gb-title">
    <div class="gb-header">
      <div style="display:flex;align-items:center;gap:8px;">
        <div style="font-weight:700;font-size:14px" id="gb-title">Guestbook</div>
        <div class="gb-sub">dark board — leave a note or drawing</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="gb-admin-toggle" id="gb-admin-toggle" title="Admin mode" aria-label="Admin toggle">⚙️</button>
        <button class="gb-close" id="gb-close" title="Close" aria-label="Close guestbook">✕</button>
      </div>
    </div>

    <div class="gb-body">
      <form id="gb-form" class="gb-form" onsubmit="return false;">
        <input id="gb-name" type="text" placeholder="Your name (optional)" maxlength="50" />
        <textarea id="gb-text" rows="3" placeholder="Write a short message (max 300 chars)" maxlength="300"></textarea>

        <div class="gb-actions">
          <button type="button" class="gb-btn ghost" id="gb-toggle-draw">Add drawing</button>
          <button type="button" class="gb-btn" id="gb-submit">Post</button>
          <div style="flex:1"></div>
          <div class="gb-muted" id="gb-count">0 messages</div>
        </div>

        <div class="gb-drawer" id="gb-drawer" aria-hidden="true">
          <div class="gb-canvas-wrap">
            <canvas id="gb-canvas" class="gb-canvas" width="300" height="200"></canvas>
            <div class="gb-tools" aria-hidden="true">
              <label class="gb-tool" title="Color"><input id="gb-color" type="color" value="#111111" style="border:0;background:transparent;width:28px;height:28px;padding:0" /></label>
              <button class="gb-tool" id="gb-brush-small" title="Small brush">●</button>
              <button class="gb-tool" id="gb-brush-medium" title="Medium brush">●●</button>
              <button class="gb-tool" id="gb-brush-large" title="Large brush">●●●</button>
              <button class="gb-tool" id="gb-undo" title="Undo last stroke">↶</button>
              <button class="gb-tool" id="gb-clear" title="Clear drawing">⤲</button>
            </div>
          </div>
          <div style="font-size:12px;color:var(--gb-muted);margin-top:8px">Draw a small note. It will be attached as an image to your post.</div>
        </div>
      </form>

      <div class="gb-messages" id="gb-messages" aria-live="polite"></div>
    </div>

    <div class="gb-footer">
      <div class="gb-muted">Local-only by default. Set up a server for public persistence.</div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="gb-btn ghost" id="gb-clear-all" title="Clear local messages">Clear local</button>
      </div>
    </div>
  </div>
</div>

<!-- GUESTBOOK WIDGET END -->

<!-- Firebase-backed guestbook script (module) -->
<script type="module">
/*
  Firebase-backed guestbook widget
  - Uses Firestore collection "notes"
  - Stores drawings in Storage under "drawings/"
  - Requires you to enable Firestore, Storage, and Anonymous Auth in your Firebase console.
  - Adjust storageBucket below if your project uses a different bucket.
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
import {
  getFirestore, collection, addDoc, onSnapshot, query, orderBy, serverTimestamp, deleteDoc, doc, getDoc
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
import {
  getStorage, ref as storageRef, uploadString, getDownloadURL, deleteObject
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-storage.js";

/* ==============
   Your Firebase config (you provided earlier) — storageBucket corrected to typical format
   ============== */
const firebaseConfig = {
  apiKey: "AIzaSyBeXCRIeRdHr2C3EYnDwC1NoQNQxZygA0U",
  authDomain: "guestbook-bfbdc.firebaseapp.com",
  databaseURL: "https://guestbook-bfbdc-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "guestbook-bfbdc",
  storageBucket: "guestbook-bfbdc.appspot.com", /* corrected to .appspot.com */
  messagingSenderId: "710789947600",
  appId: "1:710789947600:web:19014ef99d053f4c5dbed5",
  measurementId: "G-E9XPN9563X"
};

/* Initialize Firebase */
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

/* Auto anonymous auth (recommended to enable in console) */
let currentUser = null;
signInAnonymously(auth).catch((err) => {
  console.warn("Anonymous sign-in failed:", err);
});
onAuthStateChanged(auth, (user) => {
  currentUser = user;
});

/* Elements */
const trigger = document.getElementById('gb-trigger');
const backdrop = document.getElementById('gb-backdrop');
const modal = backdrop.querySelector('.gb-modal');
const closeBtn = document.getElementById('gb-close');
const adminBtn = document.getElementById('gb-admin-toggle');
const form = document.getElementById('gb-form');
const inputName = document.getElementById('gb-name');
const inputText = document.getElementById('gb-text');
const submitBtn = document.getElementById('gb-submit');
const drawerToggle = document.getElementById('gb-toggle-draw');
const drawer = document.getElementById('gb-drawer');
const messagesWrap = document.getElementById('gb-messages');
const countLabel = document.getElementById('gb-count');
const clearLocalBtn = document.getElementById('gb-clear-all');

const canvas = document.getElementById('gb-canvas');
const ctx = canvas.getContext('2d');
const colorInput = document.getElementById('gb-color');
const brushSmall = document.getElementById('gb-brush-small');
const brushMedium = document.getElementById('gb-brush-medium');
const brushLarge = document.getElementById('gb-brush-large');
const undoBtn = document.getElementById('gb-undo');
const clearBtn = document.getElementById('gb-clear');

let strokes = [];
let currentStroke = null;
let drawing = false;
let adminMode = false;
let messages = [];

/* Utility */
function makeId(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8); }

function resizeCanvasForDPR(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = 300, h = 200;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  redrawAll();
}

function drawStroke(ctxLocal, stroke){
  if(!stroke || !stroke.points || stroke.points.length<1) return;
  ctxLocal.beginPath();
  ctxLocal.lineCap = 'round';
  ctxLocal.lineJoin = 'round';
  ctxLocal.strokeStyle = stroke.color || '#111';
  ctxLocal.lineWidth = stroke.width || 3;
  const p0 = stroke.points[0];
  ctxLocal.moveTo(p0.x, p0.y);
  for(let i=1;i<stroke.points.length;i++){
    const p = stroke.points[i];
    ctxLocal.lineTo(p.x, p.y);
  }
  ctxLocal.stroke();
  ctxLocal.closePath();
}

function redrawAll(){
  // note: canvas.width/height are device px; ctx transform handles DPR
  ctx.clearRect(0,0,canvas.width, canvas.height);
  ctx.save();
  ctx.scale(1,1);
  for(const s of strokes) drawStroke(ctx, s);
  ctx.restore();
}

function getPointer(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
  const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
  return { x: clientX - rect.left, y: clientY - rect.top };
}

function startDraw(e){
  e.preventDefault();
  drawing = true;
  const pt = getPointer(e);
  currentStroke = { color: colorInput.value || '#111', width: Number(canvas.dataset.brush) || 3, points: [{x:pt.x, y:pt.y}] };
  strokes.push(currentStroke);
  redrawAll();
}
function moveDraw(e){
  if(!drawing) return;
  e.preventDefault();
  const pt = getPointer(e);
  currentStroke.points.push({x:pt.x, y:pt.y});
  redrawAll();
}
function endDraw(e){
  if(!drawing) return;
  drawing = false;
  currentStroke = null;
  redrawAll();
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('touchstart', startDraw, {passive:false});
window.addEventListener('mousemove', moveDraw);
window.addEventListener('touchmove', moveDraw, {passive:false});
window.addEventListener('mouseup', endDraw);
window.addEventListener('touchend', endDraw);

function setBrushSize(sz){ canvas.dataset.brush = sz; }
setBrushSize(3);
brushSmall.addEventListener('click', ()=> setBrushSize(2));
brushMedium.addEventListener('click', ()=> setBrushSize(4));
brushLarge.addEventListener('click', ()=> setBrushSize(6));
undoBtn.addEventListener('click', ()=> { strokes.pop(); redrawAll(); });
clearBtn.addEventListener('click', ()=> { strokes = []; redrawAll(); });

function canvasToDataUrl(){
  if(strokes.length===0) return null;
  // scale up slightly for nicer images, keep aspect ratio
  const outW = 600, outH = 400;
  const tmp = document.createElement('canvas');
  tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff';
  tctx.fillRect(0,0,outW,outH);
  // compute scale from canvas.style dims
  const srcW = parseFloat(canvas.style.width), srcH = parseFloat(canvas.style.height);
  const sx = outW / srcW, sy = outH / srcH;
  tctx.save(); tctx.scale(sx, sy);
  for(const s of strokes) drawStroke(tctx, s);
  tctx.restore();
  // compress to jpeg to save space (but keep alpha-free)
  try {
    return tmp.toDataURL('image/jpeg', 0.86);
  } catch (e) {
    return tmp.toDataURL('image/png');
  }
}

/* Firebase interactions */

/* Listen for notes in realtime */
const notesCol = collection(db, 'notes');
const notesQuery = query(notesCol, orderBy('createdAt', 'desc'));

/* Render helper */
function renderMessagesList(entries){
  messagesWrap.innerHTML = '';
  for(const m of entries){
    const ent = document.createElement('div'); ent.className = 'gb-msg';
    const left = document.createElement('div'); left.style.flex = '1';
    const meta = document.createElement('div'); meta.className = 'meta';
    const who = document.createElement('div'); who.style.fontWeight = '600'; who.textContent = m.name || 'Anonymous';
    const when = document.createElement('div'); when.style.color = 'var(--gb-muted)'; when.textContent = new Date(m.createdAt).toLocaleString();
    meta.appendChild(who); meta.appendChild(when);
    left.appendChild(meta);
    if(m.text){
      const p = document.createElement('div'); p.className = 'content'; p.textContent = m.text; left.appendChild(p);
    }
    if(m.imageUrl){
      const img = document.createElement('img'); img.alt = 'drawing'; img.src = m.imageUrl; img.style.marginTop = '8px'; left.appendChild(img);
    }
    ent.appendChild(left);

    const controls = document.createElement('div'); controls.className = 'controls';
    const copyBtn = document.createElement('button'); copyBtn.className = 'copy'; copyBtn.textContent = 'Copy';
    copyBtn.addEventListener('click', ()=> copyEntryToClipboard(m));
    controls.appendChild(copyBtn);

    if(adminMode){
      const del = document.createElement('button'); del.className = 'del'; del.textContent = 'Delete';
      del.addEventListener('click', ()=> removeMessage(m.id, m.storagePath));
      controls.appendChild(del);
    }

    ent.appendChild(controls);
    messagesWrap.appendChild(ent);
  }
  countLabel.textContent = entries.length + (entries.length === 1 ? ' message' : ' messages');
}

/* Real-time listener updates local 'messages' */
let unsubscribeNotes = null;
function attachRealtimeListener(){
  if(unsubscribeNotes) unsubscribeNotes();
  unsubscribeNotes = onSnapshot(notesQuery, (snap) => {
    const arr = [];
    snap.forEach(docSnap => {
      const d = docSnap.data();
      arr.push({
        id: docSnap.id,
        name: d.name || '',
        text: d.text || '',
        imageUrl: d.imageUrl || null,
        storagePath: d.storagePath || null,
        createdAt: d.createdAt ? (d.createdAt.toDate ? d.createdAt.toDate().toISOString() : d.createdAt) : new Date().toISOString()
      });
    });
    messages = arr;
    renderMessagesList(messages);
  }, (err) => {
    console.error('notes listener error', err);
  });
}

/* Add message (text + optional drawing) */
async function addMessage(entry){
  // entry: { name, text, imageDataUrl (optional) }
  const docData = {
    name: entry.name || '',
    text: entry.text || '',
    createdAt: serverTimestamp(),
    uid: currentUser ? currentUser.uid : null
  };
  try {
    if(entry.imageDataUrl){
      // store image to storage, then include URL and path in doc
      const path = `drawings/${Date.now()}-${makeId()}.jpg`;
      const sref = storageRef(storage, path);
      // upload data url
      await uploadString(sref, entry.imageDataUrl, 'data_url');
      const url = await getDownloadURL(sref);
      docData.imageUrl = url;
      docData.storagePath = path;
    }
    const added = await addDoc(notesCol, docData);
    // addDoc returns ref; onSnapshot will refresh UI
    return added.id;
  } catch (err) {
    console.error('addMessage failed', err);
    throw err;
  }
}

/* Remove message by id (admin only) */
async function removeMessage(id, storagePath){
  if(!confirm('Delete this entry? This action cannot be undone.')) return;
  try {
    await deleteDoc(doc(db, 'notes', id));
    if(storagePath){
      try {
        const sref = storageRef(storage, storagePath);
        await deleteObject(sref);
      } catch (e) {
        console.warn('Failed deleting storage object (may be already gone):', e);
      }
    }
    // onSnapshot will refresh UI
  } catch (err) {
    console.error('removeMessage failed', err);
    alert('Delete failed: ' + (err && err.message ? err.message : err));
  }
}

/* Copy entry to clipboard (tries to copy image + text if supported) */
async function copyEntryToClipboard(entry){
  const text = (entry.name ? entry.name + '\n\n' : '') + (entry.text || '');
  try {
    if(entry.imageUrl && navigator.clipboard && navigator.clipboard.write){
      // fetch image blob and attempt multi-item clipboard write
      const res = await fetch(entry.imageUrl);
      const blob = await res.blob();
      const items = {};
      items['text/plain'] = new Blob([text], { type: 'text/plain' });
      items[blob.type] = blob;
      const clipboardItem = new ClipboardItem(items);
      await navigator.clipboard.write([clipboardItem]);
      alert('Copied text + image to clipboard.');
      return;
    }
  } catch (e) {
    console.warn('image copy failed', e);
  }
  try {
    const fallback = entry.imageUrl ? text + '\n\n' + entry.imageUrl : text;
    await navigator.clipboard.writeText(fallback);
    alert('Copied text to clipboard.');
  } catch (e) {
    alert('Copy failed: ' + (e && e.message ? e.message : e));
  }
}

/* UI wiring */

/* Toggle modal */
trigger.addEventListener('click', ()=> {
  backdrop.classList.add('active');
  backdrop.setAttribute('aria-hidden','false');
  // Attach realtime listener when modal opens
  attachRealtimeListener();
});

closeBtn.addEventListener('click', ()=> {
  backdrop.classList.remove('active');
  backdrop.setAttribute('aria-hidden','true');
  // detach listener
  if(unsubscribeNotes) { unsubscribeNotes(); unsubscribeNotes = null; }
});

backdrop.addEventListener('click', (e)=> {
  if(e.target===backdrop){
    backdrop.classList.remove('active');
    backdrop.setAttribute('aria-hidden','true');
    if(unsubscribeNotes) { unsubscribeNotes(); unsubscribeNotes = null; }
  }
});

/* Toggle drawing area */
drawerToggle.addEventListener('click', ()=>{
  drawer.classList.toggle('active');
  resizeCanvasForDPR();
});

/* Submit post */
submitBtn.addEventListener('click', async ()=>{
  const name = (inputName.value || '').trim().slice(0,50);
  const text = (inputText.value || '').trim().slice(0,300);
  if(!text && strokes.length===0){ alert('Please enter a message or draw something.'); return; }
  submitBtn.disabled = true;
  submitBtn.textContent = 'Posting...';
  try {
    const imageData = canvasToDataUrl(); // returns data URL or null
    await addMessage({ name, text, imageDataUrl: imageData });
    inputText.value = ''; inputName.value = '';
    strokes = []; redrawAll();
    drawer.classList.remove('active');
  } catch (err) {
    alert('Failed to post: ' + (err && err.message ? err.message : err));
  } finally {
    submitBtn.disabled = false;
    submitBtn.textContent = 'Post';
  }
});

/* Clear local (does not remove remote data) */
clearLocalBtn.addEventListener('click', ()=>{
  if(!confirm('Clear all local messages? This only affects this browser.')) return;
  // local-only: simply clear the UI cache (messages are live from Firestore so this is cosmetic)
  messages = [];
  renderMessagesList(messages);
});

/* Admin toggle (client-side toggle only; server-side deletion still requires Firebase console or this client if adminMode true) */
adminBtn.addEventListener('click', ()=>{
  if(adminMode){
    adminMode = false; adminBtn.textContent = '⚙️'; renderMessagesList(messages); return;
  }
  const attempt = prompt('Enter guestbook admin password (client-side):');
  // NOTE: This is purely UI-side gate. For secure admin control, use the Firebase console.
  if(attempt && attempt === 'synt-guestbook'){ // simple local comparison; replace with secure flow as needed
    adminMode = true; adminBtn.textContent = '🔒';
    renderMessagesList(messages);
  } else {
    alert('Incorrect password (or cancel). For secure moderation use the Firebase console.');
  }
});

/* Keyboard open (Ctrl/Cmd+G) */
window.addEventListener('keydown', (e)=>{
  if((e.key === 'g' || e.key === 'G') && (e.ctrlKey || e.metaKey)){
    e.preventDefault();
    if(backdrop.classList.contains('active')) { backdrop.classList.remove('active'); backdrop.setAttribute('aria-hidden','true'); if(unsubscribeNotes) { unsubscribeNotes(); unsubscribeNotes = null; } }
    else { backdrop.classList.add('active'); backdrop.setAttribute('aria-hidden','false'); attachRealtimeListener(); }
  }
});

/* Initialize */
resizeCanvasForDPR();
window.addEventListener('resize', resizeCanvasForDPR);

// Optionally attach listener even when modal not open to show live count; uncomment if desired:
// attachRealtimeListener();

</script>

<!-- GUESTBOOK WIDGET END -->

</body>
</html>
